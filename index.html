<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stickman Fighter</title>
  <!-- Load Socket.io from CDN -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          touch-action: none;
          background-color: #222;
          font-family: Arial, sans-serif;
      }
      #gameContainer {
          position: relative;
          width: 100vw;
          height: 100vh;
          overflow: hidden;
      }
      #gameCanvas {
          background-color: #333;
          position: absolute;
          top: 0;
          left: 0;
      }
      .controls {
          position: fixed;
          bottom: 30px; /* Increased from 20px to move controls lower */
          width: 100%;
          padding: 0 10px;
          box-sizing: border-box;
          z-index: 10;
          display: flex;
          justify-content: center;
      }
      .player-controls {
          display: flex;
          gap: 12px;
          margin-bottom: 15px; /* Extra margin at the bottom */
      }
      .control-btn {
          width: 65px;
          height: 65px;
          border-radius: 50%;
          border: none;
          background-color: rgba(255, 255, 255, 0.3);
          color: white;
          font-weight: bold;
          font-size: 18px;
          touch-action: manipulation;
          user-select: none;
          -webkit-user-select: none;
          /* Add transition for smooth feedback */
          transition: all 0.1s ease;
          position: relative;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      /* Button press effect */
      .control-btn.active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
      }
      @media (max-width: 480px) {
          .control-btn {
              width: 55px;
              height: 55px;
              font-size: 16px;
          }
          .player-controls {
              gap: 10px;
          }
      }
      @media (max-width: 360px) {
          .control-btn {
              width: 45px;
              height: 45px;
              font-size: 14px;
          }
          .player-controls {
              gap: 8px;
          }
      }
      .hit-btn {
          background-color: rgba(255, 50, 50, 0.7);
      }
      .hit-btn.active {
          background-color: rgba(255, 50, 50, 0.9);
      }
      .kick-btn {
          background-color: rgba(50, 50, 255, 0.7);
      }
      .kick-btn.active {
          background-color: rgba(50, 50, 255, 0.9);
      }
      .move-btn {
          background-color: rgba(50, 200, 50, 0.7);
      }
      .move-btn.active {
          background-color: rgba(50, 200, 50, 0.9);
      }
      /* Button ripple effect */
      .control-btn::after {
          content: '';
          position: absolute;
          top: 50%;
          left: 50%;
          width: 5px;
          height: 5px;
          background: rgba(255, 255, 255, 0.5);
          opacity: 0;
          border-radius: 100%;
          transform: scale(1, 1) translate(-50%, -50%);
          transform-origin: 50% 50%;
      }
      .control-btn.active::after {
          animation: ripple 0.4s ease-out;
      }
      @keyframes ripple {
          0% {
              transform: scale(0, 0) translate(-50%, -50%);
              opacity: 0.5;
          }
          100% {
              transform: scale(20, 20) translate(-50%, -50%);
              opacity: 0;
          }
      }
      #winnerMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 30px;
          border-radius: 10px;
          font-size: 24px;
          display: none;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #restartBtn {
          margin-top: 20px;
          padding: 15px 30px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 18px;
          touch-action: manipulation;
          transition: all 0.1s ease;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      #restartBtn:active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
          background-color: #3e8e41;
      }
      #restartBtn:disabled {
          background-color: #888;
          cursor: default;
          transform: none;
          box-shadow: none;
      }
      #waitingMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 20px;
          border-radius: 10px;
          font-size: 20px;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #playerIndicator {
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 16px;
          z-index: 30;
          text-align: center;
      }
      #debugInfo {
          position: fixed;
          top: 40px;
          left: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          font-size: 12px;
          z-index: 30;
          display: none;
      }
      /* Add a game area container to help with positioning */
      #gameArea {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: calc(100% - 130px); /* Reserve space for controls */
          overflow: hidden;
      }
      /* Player ready status styles */
      .player-status {
          margin-top: 10px;
          display: flex;
          justify-content: space-between;
          width: 100%;
      }
      .status-indicator {
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
      }
      .status-waiting {
          color: #ff5555;
      }
      .status-ready {
          color: #55ff55;
      }
      /* Sound control styles */
      #soundControl {
          position: fixed;
          top: 10px;
          right: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          z-index: 30;
          cursor: pointer;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
      }
  </style>
</head>
<body>
  <div id="gameContainer">
      <div id="playerIndicator"></div>
      <div id="debugInfo"></div>
      <div id="soundControl">🔊</div>
      
      <div id="gameArea">
          <canvas id="gameCanvas"></canvas>
      </div>
      
      <div class="controls" id="controlsContainer">
          <!-- Control buttons will be added here dynamically -->
      </div>
      
      <div id="winnerMessage">
          <div id="winnerText"></div>
          <div class="player-status">
              <div id="player1Status" class="status-indicator status-waiting">Player 1: Waiting</div>
              <div id="player2Status" class="status-indicator status-waiting">Player 2: Waiting</div>
          </div>
          <button id="restartBtn">Play Again</button>
      </div>
      
      <div id="waitingMessage">
          Connecting to server...
      </div>
  </div>

  <script>
      // Game variables
      let canvas, ctx;
      let gameWidth, gameHeight;
      let socket;
      let playerId;
      let players = {};
      let gameStarted = false;
      let readyPlayers = []; // Track which players are ready
      const GLITCH_SERVER_URL = "https://stickmanfightingnew.glitch.me";
      
      // Sound variables
      let soundEnabled = true;
      let sounds = {};
      let soundsLoaded = false;
      
      // Game constants
      const PLAYER_WIDTH = 30;
      const PLAYER_HEIGHT = 80;
      const PLAYER_SPEED = 5;
      const MAX_POWER = 100;
      const HIT_DAMAGE = 10;
      const KICK_DAMAGE = 15;
      const HIT_RANGE = 40;
      const KICK_RANGE = 50;
      
      // Animation states
      const IDLE = 'idle';
      const HITTING = 'hitting';
      const KICKING = 'kicking';
      const HURT = 'hurt';
      
      // Debug function
      function debug(message) {
          const debugElement = document.getElementById('debugInfo');
          debugElement.style.display = 'block';
          debugElement.textContent = message;
          console.log(message);
      }
      
      // Initialize the game
      window.onload = function() {
          canvas = document.getElementById('gameCanvas');
          ctx = canvas.getContext('2d');
          
          // Set canvas size
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          
          // Load sounds
          loadSounds();
          
          // Set up sound control
          setupSoundControl();
          
          // Connect to server automatically
          connectToServer();
          
          // Set up restart button with multiple event types
          setupRestartButton();
          
          // Start game loop
          requestAnimationFrame(gameLoop);
      };
      
      // Load all game sounds
      function loadSounds() {
          const soundFiles = {
              hit: 'Stickman-Fighter-v2/assets/hit.mp3',
              kick: 'Stickman-Fighter-v2/assets/kick.mp3',
              hurt: '/sounds/hurt.mp3',
              victory: '/sounds/victory.mp3',
              gameStart: '/sounds/game-start.mp3',
              button: '/sounds/button-click.mp3'
          };
          
          let loadedCount = 0;
          const totalSounds = Object.keys(soundFiles).length;
          
          // Create audio objects for each sound
          for (const [name, url] of Object.entries(soundFiles)) {
              sounds[name] = new Audio();
              sounds[name].src = url;
              
              // Handle loading
              sounds[name].addEventListener('canplaythrough', () => {
                  loadedCount++;
                  if (loadedCount === totalSounds) {
                      soundsLoaded = true;
                      console.log('All sounds loaded');
                  }
              });
              
              // Handle errors
              sounds[name].addEventListener('error', (e) => {
                  console.error(`Error loading sound ${name}:`, e);
              });
              
              // Preload the sound
              sounds[name].load();
          }
      }
      
      // Play a sound with error handling
      function playSound(name) {
          if (!soundEnabled || !soundsLoaded) return;
          
          try {
              // Create a clone to allow overlapping sounds
              const sound = sounds[name].cloneNode();
              sound.volume = 0.5; // Set volume to 50%
              
              // Play the sound with a promise and catch any errors
              const playPromise = sound.play();
              
              if (playPromise !== undefined) {
                  playPromise.catch(error => {
                      console.warn(`Sound play error (${name}):`, error);
                  });
              }
          } catch (error) {
              console.error(`Error playing sound ${name}:`, error);
          }
      }
      
      // Set up sound control button
      function setupSoundControl() {
          const soundControl = document.getElementById('soundControl');
          
          soundControl.addEventListener('click', function() {
              soundEnabled = !soundEnabled;
              this.textContent = soundEnabled ? '🔊' : '🔇';
              
              // Play a sound to confirm it's working
              if (soundEnabled) {
                  playSound('button');
              }
          });
      }
      
      function resizeCanvas() {
          // Get the gameArea dimensions
          const gameArea = document.getElementById('gameArea');
          gameWidth = gameArea.clientWidth;
          gameHeight = gameArea.clientHeight;
          
          canvas.width = gameWidth;
          canvas.height = gameHeight;
      }
      
      function connectToServer() {
          try {
              // Connect to the hardcoded Glitch server
              socket = io(GLITCH_SERVER_URL, {
                  transports: ['websocket', 'polling'],
                  reconnectionAttempts: 5
              });
              
              socket.on('connect', function() {
                  console.log('Connected to server');
                  document.getElementById('waitingMessage').textContent = 'Waiting for another player to join...';
              });
              
              socket.on('connect_error', function(error) {
                  console.error('Connection error:', error);
                  document.getElementById('waitingMessage').textContent = 'Connection error. Please try again.';
                  // Try to reconnect after 3 seconds
                  setTimeout(connectToServer, 3000);
              });
              
              socket.on('playerId', function(id) {
                  playerId = id;
                  console.log('Your player ID:', playerId);
                  
                  // Show player indicator
                  document.getElementById('playerIndicator').textContent = 
                      id === 'player1' ? 'You are Player 1 (Red)' : 'You are Player 2 (Blue)';
                  
                  // Set up controls for this player
                  setupPlayerControls();
              });
              
              socket.on('gameState', function(state) {
                  // Track previous player states to detect changes for sound effects
                  const prevPlayer1State = players.player1 ? players.player1.state : null;
                  const prevPlayer2State = players.player2 ? players.player2.state : null;
                  const wasGameStarted = gameStarted;
                  
                  players = state.players;
                  gameStarted = state.gameStarted;
                  
                  // Play game start sound when game begins
                  if (gameStarted && !wasGameStarted) {
                      playSound('gameStart');
                  }
                  
                  // Play sounds based on state changes
                  if (players.player1 && prevPlayer1State !== players.player1.state) {
                      if (players.player1.state === HITTING) playSound('hit');
                      if (players.player1.state === KICKING) playSound('kick');
                      if (players.player1.state === HURT) playSound('hurt');
                  }
                  
                  if (players.player2 && prevPlayer2State !== players.player2.state) {
                      if (players.player2.state === HITTING) playSound('hit');
                      if (players.player2.state === KICKING) playSound('kick');
                      if (players.player2.state === HURT) playSound('hurt');
                  }
                  
                  // Show/hide waiting message
                  document.getElementById('waitingMessage').style.display = 
                      gameStarted ? 'none' : 'block';
                  
                  // Check for winner
                  if (state.winner) {
                      showWinner(state.winner);
                      playSound('victory');
                  } else if (state.winner === null && document.getElementById('winnerMessage').style.display === 'block') {
                      // Game has been reset, hide winner message
                      document.getElementById('winnerMessage').style.display = 'none';
                      
                      // Reset button state
                      const restartBtn = document.getElementById('restartBtn');
                      restartBtn.textContent = 'Play Again';
                      restartBtn.disabled = false;
                      
                      // Reset player status indicators
                      document.getElementById('player1Status').className = 'status-indicator status-waiting';
                      document.getElementById('player1Status').textContent = 'Player 1: Waiting';
                      document.getElementById('player2Status').className = 'status-indicator status-waiting';
                      document.getElementById('player2Status').textContent = 'Player 2: Waiting';
                      
                      // Clear ready players array
                      readyPlayers = [];
                  }
              });
              
              // Listen for player ready status updates
              socket.on('playerReady', function(players) {
                  readyPlayers = players;
                  updateReadyStatus();
                  
                  debug("Ready players: " + JSON.stringify(readyPlayers));
                  
                  // If this player is ready, update button state
                  if (readyPlayers.includes(playerId)) {
                      const restartBtn = document.getElementById('restartBtn');
                      restartBtn.textContent = 'Waiting for other player...';
                      restartBtn.disabled = true;
                  }
                  
                  // Play button sound when a player gets ready
                  playSound('button');
              });
          } catch (error) {
              console.error('Error connecting to server:', error);
              document.getElementById('waitingMessage').textContent = 'Failed to connect to server. Please try again.';
              // Try to reconnect after 3 seconds
              setTimeout(connectToServer, 3000);
          }
      }
      
      function updateReadyStatus() {
          // Update player 1 status
          const player1Status = document.getElementById('player1Status');
          if (readyPlayers.includes('player1')) {
              player1Status.className = 'status-indicator status-ready';
              player1Status.textContent = 'Player 1: Ready';
          } else {
              player1Status.className = 'status-indicator status-waiting';
              player1Status.textContent = 'Player 1: Waiting';
          }
          
          // Update player 2 status
          const player2Status = document.getElementById('player2Status');
          if (readyPlayers.includes('player2')) {
              player2Status.className = 'status-indicator status-ready';
              player2Status.textContent = 'Player 2: Ready';
          } else {
              player2Status.className = 'status-indicator status-waiting';
              player2Status.textContent = 'Player 2: Waiting';
          }
      }
      
      function setupPlayerControls() {
          const controlsContainer = document.getElementById('controlsContainer');
          
          // Clear any existing controls
          controlsContainer.innerHTML = '';
          
          // Create new control container
          const playerControls = document.createElement('div');
          playerControls.className = 'player-controls';
          playerControls.innerHTML = `
              <button class="control-btn move-btn" id="moveLeft">←</button>
              <button class="control-btn move-btn" id="moveRight">→</button>
              <button class="control-btn hit-btn" id="hitBtn">HIT</button>
              <button class="control-btn kick-btn" id="kickBtn">KICK</button>
          `;
          
          controlsContainer.appendChild(playerControls);
          
          // Setup touch event listeners
          setupControlEventListeners();
      }
      
      function setupControlEventListeners() {
          // Get all control buttons
          const moveLeftBtn = document.getElementById('moveLeft');
          const moveRightBtn = document.getElementById('moveRight');
          const hitBtn = document.getElementById('hitBtn');
          const kickBtn = document.getElementById('kickBtn');
          
          // Clear any existing event listeners (just in case)
          moveLeftBtn.replaceWith(moveLeftBtn.cloneNode(true));
          moveRightBtn.replaceWith(moveRightBtn.cloneNode(true));
          hitBtn.replaceWith(hitBtn.cloneNode(true));
          kickBtn.replaceWith(kickBtn.cloneNode(true));
          
          // Get the fresh elements
          const newMoveLeftBtn = document.getElementById('moveLeft');
          const newMoveRightBtn = document.getElementById('moveRight');
          const newHitBtn = document.getElementById('hitBtn');
          const newKickBtn = document.getElementById('kickBtn');
          
          // Add touch start event listeners
          newMoveLeftBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket) socket.emit('attack', {type: 'hit'});
          });
          
          newKickBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket) socket.emit('attack', {type: 'kick'});
          });
          
          // Add touch end event listeners
          newMoveLeftBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          // For mouse users (testing)
          newMoveLeftBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket) socket.emit('attack', {type: 'hit'});
          });
          
          newKickBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket) socket.emit('attack', {type: 'kick'});
          });
          
          newMoveLeftBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          // Setup keyboard controls
          setupKeyboardControls();
      }
      
      function setupKeyboardControls() {
          // Remove any existing event listeners
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
          
          // Add event listeners
          window.addEventListener('keydown', handleKeyDown);
          window.addEventListener('keyup', handleKeyUp);
      }
      
      function handleKeyDown(e) {
          if (!socket || !playerId) return;
          
          let buttonId = null;
          let command = null;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
          }
          
          // Add active class to the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button && !button.classList.contains('active')) {
                  button.classList.add('active');
              }
              
              // Send command to server
              if (command) {
                  if (command.type === 'move') {
                      socket.emit('move', command.data);
                  } else if (command.type === 'attack') {
                      socket.emit('attack', command.data);
                  }
              }
          }
      }
      
      function handleKeyUp(e) {
          if (!socket || !playerId) return;
          
          let buttonId = null;
          let shouldStopMove = false;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
              }
          }
          
          // Remove active class from the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button) {
                  button.classList.remove('active');
              }
              
              // Stop movement if needed
              if (shouldStopMove) {
                  socket.emit('stopMove');
              }
          }
      }
      
      function setupRestartButton() {
          const restartBtn = document.getElementById('restartBtn');
          
          // Add event handler for restart button
          restartBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              
              if (socket && playerId) {
                  // Play button sound
                  playSound('button');
                  
                  // Send player ready status to server
                  socket.emit('playerReady', playerId);
                  
                  // Update button state
                  this.textContent = 'Waiting for other player...';
                  this.disabled = true;
                  
                  debug("Sent playerReady: " + playerId);
              }
          });
      }
      
      function gameLoop() {
          // Clear canvas
          ctx.clearRect(0, 0, gameWidth, gameHeight);
          
          if (gameStarted) {
              // Draw game elements
              drawBackground();
              drawPlayers();
              drawPowerBars();
          }
          
          // Continue the game loop
          requestAnimationFrame(gameLoop);
      }
      
      function drawBackground() {
          // Draw floor
          ctx.fillStyle = '#555';
          ctx.fillRect(0, gameHeight - 50, gameWidth, 50);
          
          // Draw background elements
          ctx.fillStyle = '#444';
          for (let i = 0; i < 5; i++) {
              ctx.fillRect(gameWidth * i / 5, gameHeight - 150, 10, 100);
          }
      }
      
      function drawPlayers() {
          if (!players.player1 || !players.player2) return;
          
          // Calculate scale factor based on screen width to keep players visible
          const scaleFactor = Math.min(1, gameWidth / 800);
          const floorY = gameHeight - 50;
          
          // Adjust player positions for smaller screens
          const p1ScreenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, players.player1.x * scaleFactor));
          const p2ScreenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, players.player2.x * scaleFactor));
          
          // Draw player 1
          drawStickman(
              p1ScreenX, 
              floorY - PLAYER_HEIGHT, 
              '#FF5555', 
              players.player1.state, 
              false
          );
          
          // Draw player 2
          drawStickman(
              p2ScreenX, 
              floorY - PLAYER_HEIGHT, 
              '#5555FF', 
              players.player2.state, 
              true
          );
      }
      
      function drawStickman(x, y, color, state, facingLeft) {
          ctx.save();
          
          // Flip if facing left
          if (facingLeft) {
              ctx.translate(x + PLAYER_WIDTH / 2, 0);
              ctx.scale(-1, 1);
              ctx.translate(-x - PLAYER_WIDTH / 2, 0);
          }
          
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Head
          ctx.beginPath();
          ctx.arc(x + PLAYER_WIDTH / 2, y + 10, 10, 0, Math.PI * 2);
          ctx.stroke();
          
          // Body
          ctx.beginPath();
          ctx.moveTo(x + PLAYER_WIDTH / 2, y + 20);
          ctx.lineTo(x + PLAYER_WIDTH / 2, y + 50);
          ctx.stroke();
          
          // Arms
          if (state === HITTING) {
              // Hitting pose
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30);
              ctx.lineTo(x + PLAYER_WIDTH - 5, y + 20);
              ctx.lineTo(x + PLAYER_WIDTH + 15, y + 25);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30);
              ctx.lineTo(x + 5, y + 40);
              ctx.stroke();
          } else if (state === KICKING) {
              // Kicking pose
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30);
              ctx.lineTo(x + PLAYER_WIDTH - 5, y + 25);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30);
              ctx.lineTo(x + 5, y + 25);
              ctx.stroke();
          } else {
              // Normal pose
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30);
              ctx.lineTo(x + PLAYER_WIDTH - 5, y + 25);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30);
              ctx.lineTo(x + 5, y + 25);
              ctx.stroke();
          }
          
          // Legs
          if (state === KICKING) {
              // Kicking pose
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50);
              ctx.lineTo(x + 10, y + 70);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50);
              ctx.lineTo(x + PLAYER_WIDTH + 20, y + 60);
              ctx.stroke();
          } else {
              // Normal pose
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50);
              ctx.lineTo(x + 10, y + 70);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50);
              ctx.lineTo(x + PLAYER_WIDTH - 10, y + 70);
              ctx.stroke();
          }
          
          // If hurt, draw stars around head
          if (state === HURT) {
              ctx.strokeStyle = 'yellow';
              for (let i = 0; i < 3; i++) {
                  const angle = Math.PI * 2 * i / 3;
                  const starX = x + PLAYER_WIDTH / 2 + Math.cos(angle) * 20;
                  const starY = y + 10 + Math.sin(angle) * 20;
                  
                  ctx.beginPath();
                  ctx.moveTo(starX - 5, starY);
                  ctx.lineTo(starX + 5, starY);
                  ctx.stroke();
                  
                  ctx.beginPath();
                  ctx.moveTo(starX, starY - 5);
                  ctx.lineTo(starX, starY + 5);
                  ctx.stroke();
              }
          }
          
          ctx.restore();
      }
      
      function drawPowerBars() {
          if (!players.player1 || !players.player2) return;
          
          const barHeight = 15;
          const margin = 10;
          
          // Responsive bar width based on screen size
          const barWidth = Math.min(200, (gameWidth / 2) - 20);
          
          // Player 1 power bar
          ctx.fillStyle = '#333';
          ctx.fillRect(margin, margin, barWidth, barHeight);
          
          ctx.fillStyle = '#FF5555';
          const p1PowerWidth = (players.player1.power / MAX_POWER) * barWidth;
          ctx.fillRect(margin, margin, p1PowerWidth, barHeight);
          
          ctx.strokeStyle = '#FFF';
          ctx.strokeRect(margin, margin, barWidth, barHeight);
          
          ctx.fillStyle = '#FFF';
          ctx.font = '12px Arial';
          ctx.fillText('Player 1', margin, margin + barHeight + 12);
          
          // Player 2 power bar
          ctx.fillStyle = '#333';
          ctx.fillRect(gameWidth - margin - barWidth, margin, barWidth, barHeight);
          
          ctx.fillStyle = '#5555FF';
          const p2PowerWidth = (players.player2.power / MAX_POWER) * barWidth;
          ctx.fillRect(gameWidth - margin - p2PowerWidth, margin, p2PowerWidth, barHeight);
          
          ctx.strokeStyle = '#FFF';
          ctx.strokeRect(gameWidth - margin - barWidth, margin, barWidth, barHeight);
          
          ctx.fillStyle = '#FFF';
          ctx.font = '12px Arial';
          ctx.fillText('Player 2', gameWidth - margin - barWidth, margin + barHeight + 12);
      }
      
      function showWinner(winner) {
          const winnerMessage = document.getElementById('winnerMessage');
          const winnerText = document.getElementById('winnerText');
          
          winnerText.textContent = `${winner} wins!`;
          winnerMessage.style.display = 'block';
          
          // Play victory sound
          playSound('victory');
          
          // Reset ready status indicators
          document.getElementById('player1Status').className = 'status-indicator status-waiting';
          document.getElementById('player1Status').textContent = 'Player 1: Waiting';
          document.getElementById('player2Status').className = 'status-indicator status-waiting';
          document.getElementById('player2Status').textContent = 'Player 2: Waiting';
          
          // Reset restart button
          const restartBtn = document.getElementById('restartBtn');
          restartBtn.textContent = 'Play Again';
          restartBtn.disabled = false;
          
          // Clear ready players array
          readyPlayers = [];
      }
  </script>
</body>
</html>
