<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stickman Fighter</title>
  <!-- Load Socket.io from CDN -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          touch-action: none;
          background-color: #222;
          font-family: Arial, sans-serif;
      }
      #gameContainer {
          position: relative;
          width: 100vw;
          height: 100vh;
          overflow: hidden;
      }
      #gameCanvas {
          background-color: #333;
          position: absolute;
          top: 0;
          left: 0;
      }
      .controls {
          position: fixed;
          bottom: 30px; /* Increased from 20px to move controls lower */
          width: 100%;
          padding: 0 10px;
          box-sizing: border-box;
          z-index: 10;
          display: flex;
          justify-content: center;
      }
      .player-controls {
          display: flex;
          gap: 12px;
          margin-bottom: 15px; /* Extra margin at the bottom */
      }
      .control-btn {
          width: 65px;
          height: 65px;
          border-radius: 50%;
          border: none;
          background-color: rgba(255, 255, 255, 0.3);
          color: white;
          font-weight: bold;
          font-size: 18px;
          touch-action: manipulation;
          user-select: none;
          -webkit-user-select: none;
          /* Add transition for smooth feedback */
          transition: all 0.1s ease;
          position: relative;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      /* Button press effect */
      .control-btn.active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
      }
      @media (max-width: 480px) {
          .control-btn {
              width: 55px;
              height: 55px;
              font-size: 16px;
          }
          .player-controls {
              gap: 10px;
          }
      }
      @media (max-width: 360px) {
          .control-btn {
              width: 45px;
              height: 45px;
              font-size: 14px;
          }
          .player-controls {
              gap: 8px;
          }
      }
      .hit-btn {
          background-color: rgba(255, 50, 50, 0.7);
      }
      .hit-btn.active {
          background-color: rgba(255, 50, 50, 0.9);
      }
      .kick-btn {
          background-color: rgba(50, 50, 255, 0.7);
      }
      .kick-btn.active {
          background-color: rgba(50, 50, 255, 0.9);
      }
      .move-btn {
          background-color: rgba(50, 200, 50, 0.7);
      }
      .move-btn.active {
          background-color: rgba(50, 200, 50, 0.9);
      }
      /* Button ripple effect */
      .control-btn::after {
          content: '';
          position: absolute;
          top: 50%;
          left: 50%;
          width: 5px;
          height: 5px;
          background: rgba(255, 255, 255, 0.5);
          opacity: 0;
          border-radius: 100%;
          transform: scale(1, 1) translate(-50%, -50%);
          transform-origin: 50% 50%;
      }
      .control-btn.active::after {
          animation: ripple 0.4s ease-out;
      }
      @keyframes ripple {
          0% {
              transform: scale(0, 0) translate(-50%, -50%);
              opacity: 0.5;
          }
          100% {
              transform: scale(20, 20) translate(-50%, -50%);
              opacity: 0;
          }
      }
      #winnerMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 30px;
          border-radius: 10px;
          font-size: 24px;
          display: none;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #restartBtn {
          margin-top: 20px;
          padding: 15px 30px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 18px;
          touch-action: manipulation;
          transition: all 0.1s ease;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      #restartBtn:active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
          background-color: #3e8e41;
      }
      #restartBtn:disabled {
          background-color: #888;
          cursor: default;
          transform: none;
          box-shadow: none;
      }
      #waitingMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 20px;
          border-radius: 10px;
          font-size: 20px;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #playerIndicator {
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 16px;
          z-index: 30;
          text-align: center;
      }
      #debugInfo {
          position: fixed;
          top: 40px;
          left: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          font-size: 12px;
          z-index: 30;
          display: none;
      }
      /* Add a game area container to help with positioning */
      #gameArea {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: calc(100% - 130px); /* Reserve space for controls */
          overflow: hidden;
      }
      /* Player ready status styles */
      .player-status {
          margin-top: 10px;
          display: flex;
          justify-content: space-between;
          width: 100%;
      }
      .status-indicator {
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
      }
      .status-waiting {
          color: #ff5555;
      }
      .status-ready {
          color: #55ff55;
      }
      /* Sound control styles */
      #soundControl {
          position: fixed;
          top: 10px;
          right: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          z-index: 30;
          cursor: pointer;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
      }
  </style>
</head>
<body>
  <div id="gameContainer">
      <div id="playerIndicator"></div>
      <div id="debugInfo"></div>
      <div id="soundControl">🔊</div>
      
      <div id="gameArea">
          <canvas id="gameCanvas"></canvas>
      </div>
      
      <div class="controls" id="controlsContainer">
          <!-- Control buttons will be added here dynamically -->
      </div>
      
      <div id="winnerMessage">
          <div id="winnerText"></div>
          <div class="player-status">
              <div id="player1Status" class="status-indicator status-waiting">Player 1: Waiting</div>
              <div id="player2Status" class="status-indicator status-waiting">Player 2: Waiting</div>
          </div>
          <button id="restartBtn">Play Again</button>
      </div>
      
      <div id="waitingMessage">
          Connecting to server...
      </div>
  </div>

  <script>
      // Game variables
      let canvas, ctx;
      let gameWidth, gameHeight;
      let socket;
      let playerId;
      let players = {};
      let gameStarted = false;
      let readyPlayers = []; // Track which players are ready
      let gameState = {};
      let gameEnding = false; // Flag to track if the game is in the ending sequence
      let gameEndTime = 0; // Time when the game ended
      let winnerAnnounced = false; // Flag to track if the winner has been announced

      // Hit detection variables
      let lastHitTime = 0;
      let hitFeedback = {
          active: false,
          x: 0,
          y: 0,
          type: '',
          time: 0
      };

      const GLITCH_SERVER_URL = "https://stickmanfightingnew.glitch.me";
      
      // Sound variables
      let soundEnabled = true;
      let sounds = {};
      let soundsLoaded = false;
      
      // Game constants
      const PLAYER_WIDTH = 30;
      const PLAYER_HEIGHT = 80;
      const PLAYER_SPEED = 5;
      const MAX_POWER = 100;
      const HIT_DAMAGE = 10;
      const KICK_DAMAGE = 15;
      const HIT_RANGE = 40;
      const KICK_RANGE = 50;
      const GAME_END_DELAY = 1500; // Delay before showing winner message (ms)

      // Hit detection constants
      const HEAD_HITBOX_RADIUS = 10;
      const BODY_HITBOX_WIDTH = 20;
      const BODY_HITBOX_HEIGHT = 30;
      const ARM_HITBOX_WIDTH = 30;
      const LEG_HITBOX_WIDTH = 30;
      const CRITICAL_HIT_MULTIPLIER = 1.5;
      const HIT_COOLDOWN = 300; // ms
      const HIT_FEEDBACK_DURATION = 200; // ms
      
      // Animation states
      const IDLE = 'idle';
      const HITTING = 'hitting';
      const KICKING = 'kicking';
      const HURT = 'hurt';
      const WALKING = 'walking';
      const VICTORY = 'victory';
      const DEFEAT = 'defeat';
      
      // Animation variables
      let animationFrame = 0;
      const ANIMATION_SPEED = 0.1; // Lower is slower
      let lastTime = 0;
      
      // Animation data for each player
      const playerAnimations = {
          player1: {
              state: IDLE,
              frame: 0,
              breatheOffset: 0,
              breatheDirection: 1,
              walkCycle: 0,
              hurtAngle: 0,
              hurtDirection: 1,
              victoryJump: 0,
              defeatFall: 0
          },
          player2: {
              state: IDLE,
              frame: 0,
              breatheOffset: 0,
              breatheDirection: 1,
              walkCycle: 0,
              hurtAngle: 0,
              hurtDirection: -1,
              victoryJump: 0,
              defeatFall: 0
          }
      };
      
      // Debug function
      function debug(message) {
          const debugElement = document.getElementById('debugInfo');
          debugElement.style.display = 'block';
          debugElement.textContent = message;
          console.log(message);
      }
      
      // Initialize the game
      window.onload = function() {
          canvas = document.getElementById('gameCanvas');
          ctx = canvas.getContext('2d');
          
          // Set canvas size
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          
          // Load sounds
          loadSounds();
          
          // Set up sound control
          setupSoundControl();
          
          // Connect to server automatically
          connectToServer();
          
          // Set up restart button with multiple event types
          setupRestartButton();
          
          // Start game loop
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
      };
      
      // Load all game sounds
      function loadSounds() {
          const soundFiles = {
              hit: '/Stickman-Fighter-v2/assets/punch.mp3',
              kick: '/Stickman-Fighter-v2/assets/kick.mp3',
              hurt: '/Stickman-Fighter-v2/assets/hurt.mp3',
              victory: '/Stickman-Fighter-v2/assets/victory.mp3',
              gameStart: '/Stickman-Fighter-v2/assets/game-start.mp3',
              button: '/Stickman-Fighter-v2/assets/button-press.mp3'
          };
          
          let loadedCount = 0;
          const totalSounds = Object.keys(soundFiles).length;
          
          // Create audio objects for each sound
          for (const [name, url] of Object.entries(soundFiles)) {
              sounds[name] = new Audio();
              sounds[name].src = url;
              
              // Handle loading
              sounds[name].addEventListener('canplaythrough', () => {
                  loadedCount++;
                  if (loadedCount === totalSounds) {
                      soundsLoaded = true;
                      console.log('All sounds loaded');
                  }
              });
              
              // Handle errors
              sounds[name].addEventListener('error', (e) => {
                  console.error(`Error loading sound ${name}:`, e);
              });
              
              // Preload the sound
              sounds[name].load();
          }
      }
      
      // Play a sound with error handling
      function playSound(name) {
          if (!soundEnabled || !soundsLoaded) return;
          
          try {
              // Create a clone to allow overlapping sounds
              const sound = sounds[name].cloneNode();
              sound.volume = 0.5; // Set volume to 50%
              
              // Play the sound with a promise and catch any errors
              const playPromise = sound.play();
              
              if (playPromise !== undefined) {
                  playPromise.catch(error => {
                      console.warn(`Sound play error (${name}):`, error);
                  });
              }
          } catch (error) {
              console.error(`Error playing sound ${name}:`, error);
          }
      }
      
      // Set up sound control button
      function setupSoundControl() {
          const soundControl = document.getElementById('soundControl');
          
          soundControl.addEventListener('click', function() {
              soundEnabled = !soundEnabled;
              this.textContent = soundEnabled ? '🔊' : '🔇';
              
              // Play a sound to confirm it's working
              if (soundEnabled) {
                  playSound('button');
              }
          });
      }
      
      function resizeCanvas() {
          // Get the gameArea dimensions
          const gameArea = document.getElementById('gameArea');
          gameWidth = gameArea.clientWidth;
          gameHeight = gameArea.clientHeight;
          
          canvas.width = gameWidth;
          canvas.height = gameHeight;
      }
      
      function connectToServer() {
          try {
              // Connect to the hardcoded Glitch server
              socket = io(GLITCH_SERVER_URL, {
                  transports: ['websocket', 'polling'],
                  reconnectionAttempts: 5
              });
              
              socket.on('connect', function() {
                  console.log('Connected to server');
                  document.getElementById('waitingMessage').textContent = 'Waiting for another player to join...';
              });
              
              socket.on('connect_error', function(error) {
                  console.error('Connection error:', error);
                  document.getElementById('waitingMessage').textContent = 'Connection error. Please try again.';
                  // Try to reconnect after 3 seconds
                  setTimeout(connectToServer, 3000);
              });
              
              socket.on('playerId', function(id) {
                  playerId = id;
                  console.log('Your player ID:', playerId);
                  
                  // Show player indicator
                  document.getElementById('playerIndicator').textContent = 
                      id === 'player1' ? 'You are Player 1 (Red)' : 'You are Player 2 (Blue)';
                  
                  // Set up controls for this player
                  setupPlayerControls();
              });
              
              socket.on('gameState', function(state) {
                  // Track previous player states to detect changes for sound effects
                  const prevPlayer1State = players.player1 ? players.player1.state : null;
                  const prevPlayer2State = players.player2 ? players.player2.state : null;
                  const prevPlayer1Power = players.player1 ? players.player1.power : MAX_POWER;
                  const prevPlayer2Power = players.player2 ? players.player2.power : MAX_POWER;
                  const wasGameStarted = gameStarted;
                  
                  // Store the previous winner
                  const prevWinner = gameState.winner;
                  
                  // Update game state
                  players = state.players;
                  gameStarted = state.gameStarted;
                  gameState = state;
                  
                  // Add isMoving property if it doesn't exist
                  if (players.player1 && players.player1.isMoving === undefined) {
                      players.player1.isMoving = false;
                  }
                  if (players.player2 && players.player2.isMoving === undefined) {
                      players.player2.isMoving = false;
                  }
                  
                  // Check if a player's health just reached zero
                  const player1Defeated = prevPlayer1Power > 0 && players.player1.power <= 0;
                  const player2Defeated = prevPlayer2Power > 0 && players.player2.power <= 0;
                  
                  // If a player was just defeated, start the game ending sequence
                  if ((player1Defeated || player2Defeated) && !gameEnding) {
                      gameEnding = true;
                      gameEndTime = performance.now();
                      
                      // Set victory/defeat animations immediately
                      if (player1Defeated) {
                          playerAnimations.player1.state = DEFEAT;
                          playerAnimations.player2.state = VICTORY;
                      } else if (player2Defeated) {
                          playerAnimations.player1.state = VICTORY;
                          playerAnimations.player2.state = DEFEAT;
                      }
                      
                      // Play hurt sound for the defeated player
                      if (player1Defeated) {
                          playSound('hurt');
                      } else if (player2Defeated) {
                          playSound('hurt');
                      }
                      
                      console.log("Game ending sequence started");
                  }
                  
                  // Update animation states based on player states
                  if (players.player1 && !gameEnding) {
                      updateAnimationState('player1', players.player1.state, players.player1.isMoving);
                  }
                  if (players.player2 && !gameEnding) {
                      updateAnimationState('player2', players.player2.state, players.player2.isMoving);
                  }
                  
                  // Play game start sound when game begins
                  if (gameStarted && !wasGameStarted) {
                      playSound('gameStart');
                  }
                  
                  // Play sounds based on state changes
                  if (players.player1 && prevPlayer1State !== players.player1.state && !gameEnding) {
                      if (players.player1.state === HITTING) playSound('hit');
                      if (players.player1.state === KICKING) playSound('kick');
                      if (players.player1.state === HURT) playSound('hurt');
                  }
                  
                  if (players.player2 && prevPlayer2State !== players.player2.state && !gameEnding) {
                      if (players.player2.state === HITTING) playSound('hit');
                      if (players.player2.state === KICKING) playSound('kick');
                      if (players.player2.state === HURT) playSound('hurt');
                  }
                  
                  // Show/hide waiting message
                  document.getElementById('waitingMessage').style.display = 
                      gameStarted ? 'none' : 'block';
                  
                  // Check for winner
                  if (state.winner && !prevWinner) {
                      // Winner was just determined
                      console.log(`Winner determined: ${state.winner}`);
                      
                      // Start the game ending sequence if it hasn't already started
                      if (!gameEnding) {
                          gameEnding = true;
                          gameEndTime = performance.now();
                          
                          // Set victory/defeat animations immediately
                          if (state.winner === 'player1') {
                              playerAnimations.player1.state = VICTORY;
                              playerAnimations.player2.state = DEFEAT;
                          } else {
                              playerAnimations.player1.state = DEFEAT;
                              playerAnimations.player2.state = VICTORY;
                          }
                          
                          // Play victory sound
                          playSound('victory');
                      }
                  } else if (state.winner === null && prevWinner) {
                      // Game has been reset
                      resetGameState();
                  }
              });
              
              // Listen for player ready status updates
              socket.on('playerReady', function(players) {
                  readyPlayers = players;
                  updateReadyStatus();
                  
                  debug("Ready players: " + JSON.stringify(readyPlayers));
                  
                  // If this player is ready, update button state
                  if (readyPlayers.includes(playerId)) {
                      const restartBtn = document.getElementById('restartBtn');
                      restartBtn.textContent = 'Waiting for other player...';
                      restartBtn.disabled = true;
                  }
                  
                  // Play button sound when a player gets ready
                  playSound('button');
              });
          } catch (error) {
              console.error('Error connecting to server:', error);
              document.getElementById('waitingMessage').textContent = 'Failed to connect to server. Please try again.';
              // Try to reconnect after 3 seconds
              setTimeout(connectToServer, 3000);
          }
      }
      
      // Reset game state when a new game starts
      function resetGameState() {
          console.log("Resetting game state");
          
          // Hide winner message
          document.getElementById('winnerMessage').style.display = 'none';
          
          // Reset button state
          const restartBtn = document.getElementById('restartBtn');
          restartBtn.textContent = 'Play Again';
          restartBtn.disabled = false;
          
          // Reset player status indicators
          document.getElementById('player1Status').className = 'status-indicator status-waiting';
          document.getElementById('player1Status').textContent = 'Player 1: Waiting';
          document.getElementById('player2Status').className = 'status-indicator status-waiting';
          document.getElementById('player2Status').textContent = 'Player 2: Waiting';
          
          // Clear ready players array
          readyPlayers = [];
          
          // Reset animation states
          playerAnimations.player1.state = IDLE;
          playerAnimations.player2.state = IDLE;
          
          // Reset game ending flags
          gameEnding = false;
          gameEndTime = 0;
          winnerAnnounced = false;
          
          // Reset hit feedback
          hitFeedback.active = false;
      }
      
      // Update animation state based on player state
      function updateAnimationState(playerId, state, isMoving) {
          const anim = playerAnimations[playerId];
          
          // Don't update if we're in the game ending sequence
          if (gameEnding) return;
          
          // Only update if state changed
          if (anim.state !== state) {
              anim.frame = 0; // Reset animation frame on state change
              
              // Reset specific animation variables
              if (state === HURT) {
                  anim.hurtAngle = 0;
                  anim.hurtDirection = playerId === 'player1' ? 1 : -1;
              }
          }
          
          // Set the animation state
          anim.state = state;
          
          // Handle walking state
          if (isMoving && state === IDLE) {
              anim.state = WALKING;
          }
      }
      
      function updateReadyStatus() {
          // Update player 1 status
          const player1Status = document.getElementById('player1Status');
          if (readyPlayers.includes('player1')) {
              player1Status.className = 'status-indicator status-ready';
              player1Status.textContent = 'Player 1: Ready';
          } else {
              player1Status.className = 'status-indicator status-waiting';
              player1Status.textContent = 'Player 1: Waiting';
          }
          
          // Update player 2 status
          const player2Status = document.getElementById('player2Status');
          if (readyPlayers.includes('player2')) {
              player2Status.className = 'status-indicator status-ready';
              player2Status.textContent = 'Player 2: Ready';
          } else {
              player2Status.className = 'status-indicator status-waiting';
              player2Status.textContent = 'Player 2: Waiting';
          }
      }
      
      function setupPlayerControls() {
          const controlsContainer = document.getElementById('controlsContainer');
          
          // Clear any existing controls
          controlsContainer.innerHTML = '';
          
          // Create new control container
          const playerControls = document.createElement('div');
          playerControls.className = 'player-controls';
          playerControls.innerHTML = `
              <button class="control-btn move-btn" id="moveLeft">←</button>
              <button class="control-btn move-btn" id="moveRight">→</button>
              <button class="control-btn hit-btn" id="hitBtn">HIT</button>
              <button class="control-btn kick-btn" id="kickBtn">KICK</button>
          `;
          
          controlsContainer.appendChild(playerControls);
          
          // Setup touch event listeners
          setupControlEventListeners();
      }
      
      function setupControlEventListeners() {
          // Get all control buttons
          const moveLeftBtn = document.getElementById('moveLeft');
          const moveRightBtn = document.getElementById('moveRight');
          const hitBtn = document.getElementById('hitBtn');
          const kickBtn = document.getElementById('kickBtn');
          
          // Clear any existing event listeners (just in case)
          moveLeftBtn.replaceWith(moveLeftBtn.cloneNode(true));
          moveRightBtn.replaceWith(moveRightBtn.cloneNode(true));
          hitBtn.replaceWith(hitBtn.cloneNode(true));
          kickBtn.replaceWith(kickBtn.cloneNode(true));
          
          // Get the fresh elements
          const newMoveLeftBtn = document.getElementById('moveLeft');
          const newMoveRightBtn = document.getElementById('moveRight');
          const newHitBtn = document.getElementById('hitBtn');
          const newKickBtn = document.getElementById('kickBtn');
          
          // Add touch start event listeners
          newMoveLeftBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'hit'});
          });
          
          newKickBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'kick'});
          });
          
          // Add touch end event listeners
          newMoveLeftBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          // For mouse users (testing)
          newMoveLeftBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'hit'});
          });
          
          newKickBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'kick'});
          });
          
          newMoveLeftBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          // Setup keyboard controls
          setupKeyboardControls();
      }
      
      function setupKeyboardControls() {
          // Remove any existing event listeners
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
          
          // Add event listeners
          window.addEventListener('keydown', handleKeyDown);
          window.addEventListener('keyup', handleKeyUp);
      }
      
      function handleKeyDown(e) {
          if (!socket || !playerId || gameEnding) return;
          
          let buttonId = null;
          let command = null;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
          }
          
          // Add active class to the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button && !button.classList.contains('active')) {
                  button.classList.add('active');
              }
              
              // Send command to server
              if (command) {
                  if (command.type === 'move') {
                      socket.emit('move', command.data);
                  } else if (command.type === 'attack') {
                      socket.emit('attack', command.data);
                  }
              }
          }
      }
      
      function handleKeyUp(e) {
          if (!socket || !playerId) return;
          
          let buttonId = null;
          let shouldStopMove = false;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
              }
          }
          
          // Remove active class from the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button) {
                  button.classList.remove('active');
              }
              
              // Stop movement if needed
              if (shouldStopMove && !gameEnding) {
                  socket.emit('stopMove');
              }
          }
      }
      
      function setupRestartButton() {
          const restartBtn = document.getElementById('restartBtn');
          
          // Add event handler for restart button
          restartBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              
              if (socket && playerId) {
                  // Play button sound
                  playSound('button');
                  
                  // Send player ready status to server
                  socket.emit('playerReady', playerId);
                  
                  // Update button state
                  this.textContent = 'Waiting for other player...';
                  this.disabled = true;
                  
                  debug("Sent playerReady: " + playerId);
              }
          });
      }
      
      function gameLoop(timestamp) {
          // Calculate delta time for smooth animations
          const deltaTime = timestamp - lastTime;
          lastTime = timestamp;
          
          // Update animation frame
          animationFrame += ANIMATION_SPEED * (deltaTime / 16.67); // Normalize to ~60fps
          
          // Update player animations
          updatePlayerAnimations(deltaTime);

          // Check for game ending sequence
          if (gameEnding && gameState.winner && !winnerAnnounced) {
              const now = performance.now();
              if (now - gameEndTime >= GAME_END_DELAY) {
                  // Show winner message after delay
                  showWinner(gameState.winner);
                  winnerAnnounced = true;
              }
          }

          // Update hit detection (only if game is active and not ending)
          if (gameStarted && !gameEnding) {
              checkHits();
          }
          
          // Clear canvas
          ctx.clearRect(0, 0, gameWidth, gameHeight);
          
          // Draw game elements
          drawBackground();

          // Always draw players, even if game is not started
          if (players.player1 && players.player2) {
              drawPlayers();
          }

          // Draw hit feedback and power bars if game is active or ending
          if (gameStarted || gameEnding) {
              drawHitFeedback();
              drawPowerBars();
              // drawHitboxes(); // Uncomment for debugging
          }
          
          // Continue the game loop
          requestAnimationFrame(gameLoop);
      }
      
      // Update player animations
      function updatePlayerAnimations(deltaTime) {
          // Update player 1 animations
          updatePlayerAnimation('player1', deltaTime);
          
          // Update player 2 animations
          updatePlayerAnimation('player2', deltaTime);
      }
      
      // Update individual player animation
      function updatePlayerAnimation(playerId, deltaTime) {
          const anim = playerAnimations[playerId];
          
          // Update breathing animation for idle
          if (anim.state === IDLE) {
              anim.breatheOffset += anim.breatheDirection * 0.02 * (deltaTime / 16.67);
              
              // Reverse direction at limits
              if (anim.breatheOffset > 1) {
                  anim.breatheOffset = 1;
                  anim.breatheDirection = -1;
              } else if (anim.breatheOffset < -1) {
                  anim.breatheOffset = -1;
                  anim.breatheDirection = 1;
              }
          }
          
          // Update walking animation
          if (anim.state === WALKING) {
              anim.walkCycle += 0.1 * (deltaTime / 16.67);
              if (anim.walkCycle > Math.PI * 2) {
                  anim.walkCycle -= Math.PI * 2;
              }
          }
          
          // Update hurt animation
          if (anim.state === HURT) {
              anim.hurtAngle += anim.hurtDirection * 0.2 * (deltaTime / 16.67);
              
              // Limit the hurt angle
              if (Math.abs(anim.hurtAngle) > Math.PI / 6) {
                  anim.hurtDirection *= -0.7; // Bounce back with damping
              }
          }
          
          // Update victory animation
          if (anim.state === VICTORY) {
              anim.victoryJump += 0.1 * (deltaTime / 16.67);
              if (anim.victoryJump > Math.PI * 2) {
                  anim.victoryJump -= Math.PI * 2;
              }
          }
          
          // Update defeat animation
          if (anim.state === DEFEAT) {
              if (anim.defeatFall < 1) {
                  anim.defeatFall += 0.02 * (deltaTime / 16.67);
                  if (anim.defeatFall > 1) anim.defeatFall = 1;
              }
          }
      }

      // Calculate hitboxes for a player
      function calculateHitboxes(playerId) {
          if (!players[playerId]) return null;
          
          const player = players[playerId];
          const anim = playerAnimations[playerId];
          const facingLeft = playerId === 'player2'; // Player 2 faces left
          
          // Calculate scale factor based on screen width
          const scaleFactor = Math.min(1, gameWidth / 800);
          const floorY = gameHeight - 50;
          
          // Adjust player positions for smaller screens
          const screenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, player.x * scaleFactor));
          const screenY = floorY - PLAYER_HEIGHT;
          
          // Apply animation offsets
          let yOffset = 0;
          if (anim.state === VICTORY) {
              yOffset = -Math.abs(Math.sin(anim.victoryJump) * 20);
          } else if (anim.state === DEFEAT) {
              yOffset = anim.defeatFall * 20;
          }
          
          // Calculate center point
          const centerX = screenX + PLAYER_WIDTH / 2;
          const headY = screenY + 10 + anim.breatheOffset + yOffset;
          
          // Calculate attack point (where hits land)
          let attackX = centerX + (facingLeft ? -ARM_HITBOX_WIDTH : ARM_HITBOX_WIDTH);
          let attackY = screenY + 25 + yOffset;
          let attackRange = 10; // Default attack range

          if (anim.state === HITTING) {
              attackRange = 10;
          } else if (anim.state === KICKING) {
              // Extend kick range and adjust position
              attackX = centerX + (facingLeft ? -LEG_HITBOX_WIDTH - 10 : LEG_HITBOX_WIDTH + 10);
              attackY = screenY + 60 + yOffset;
              attackRange = 15; // Larger range for kicks
          }
          
          return {
              id: playerId,
              head: {
                  x: centerX,
                  y: headY,
                  radius: HEAD_HITBOX_RADIUS
              },
              body: {
                  x: centerX,
                  y: screenY + 35 + yOffset,
                  width: BODY_HITBOX_WIDTH,
                  height: BODY_HITBOX_HEIGHT
              },
              attackPoint: {
                  x: attackX,
                  y: attackY,
                  active: anim.state === HITTING || anim.state === KICKING,
                  type: anim.state === HITTING ? 'hit' : 'kick',
                  range: attackRange
              }
          };
      }

      // Check for hits between players
      function checkHits() {
          if (!gameStarted || !players.player1 || !players.player2 || gameEnding) return;
          
          // Don't check hits too frequently
          const now = performance.now();
          if (now - lastHitTime < HIT_COOLDOWN) return;
          
          // Calculate hitboxes
          const p1Hitbox = calculateHitboxes('player1');
          const p2Hitbox = calculateHitboxes('player2');
          
          if (!p1Hitbox || !p2Hitbox) return;
          
          // Check player 1 attacking player 2
          if (p1Hitbox.attackPoint.active && players.player1.state !== HURT) {
              const hit = detectHit(p1Hitbox.attackPoint, p2Hitbox);
              if (hit) {
                  applyHit('player1', 'player2', p1Hitbox.attackPoint, hit);
              }
          }
          
          // Check player 2 attacking player 1
          if (p2Hitbox.attackPoint.active && players.player2.state !== HURT) {
              const hit = detectHit(p2Hitbox.attackPoint, p1Hitbox);
              if (hit) {
                  applyHit('player2', 'player1', p2Hitbox.attackPoint, hit);
              }
          }
      }

      // Detect if an attack point hits a hitbox
      function detectHit(attackPoint, targetHitbox) {
          // Get attack range (or default to 10)
          const range = attackPoint.range || 10;
          
          // Check head hit (circular collision)
          const dx = attackPoint.x - targetHitbox.head.x;
          const dy = attackPoint.y - targetHitbox.head.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < targetHitbox.head.radius + range) {
              return { zone: 'head', point: { x: targetHitbox.head.x, y: targetHitbox.head.y } };
          }
          
          // Check body hit (rectangular collision with expanded range)
          const bodyLeft = targetHitbox.body.x - targetHitbox.body.width / 2 - range;
          const bodyRight = targetHitbox.body.x + targetHitbox.body.width / 2 + range;
          const bodyTop = targetHitbox.body.y - targetHitbox.body.height / 2 - range;
          const bodyBottom = targetHitbox.body.y + targetHitbox.body.height / 2 + range;
          
          if (attackPoint.x >= bodyLeft && attackPoint.x <= bodyRight &&
              attackPoint.y >= bodyTop && attackPoint.y <= bodyBottom) {
              return { zone: 'body', point: { x: attackPoint.x, y: attackPoint.y } };
          }
          
          return null;
      }

      // Apply hit effects
      function applyHit(attackerId, targetId, attackPoint, hit) {
          // Don't register hits if the game is over
          if (gameEnding || document.getElementById('winnerMessage').style.display === 'block') return;
          
          lastHitTime = performance.now();
          
          // Calculate damage based on attack type and hit zone
          let damage = attackPoint.type === 'hit' ? HIT_DAMAGE : KICK_DAMAGE;
          
          // Critical hit for headshots
          if (hit.zone === 'head') {
              damage *= CRITICAL_HIT_MULTIPLIER;
          }
          
          // Send attack to server
          if (socket) {
              socket.emit('registerHit', {
                  attackerId: attackerId,
                  targetId: targetId,
                  damage: damage,
                  hitZone: hit.zone
              });
          }
          
          // Show hit feedback
          hitFeedback = {
              active: true,
              x: hit.point.x,
              y: hit.point.y,
              type: hit.zone === 'head' ? 'critical' : 'normal',
              time: performance.now()
          };
      }

      // Draw hit feedback
      function drawHitFeedback() {
          if (!hitFeedback.active) return;
          
          const now = performance.now();
          const elapsed = now - hitFeedback.time;
          
          if (elapsed > HIT_FEEDBACK_DURATION) {
              hitFeedback.active = false;
              return;
          }
          
          // Calculate animation progress (0 to 1)
          const progress = elapsed / HIT_FEEDBACK_DURATION;
          const size = 20 + progress * 30;
          const opacity = 1 - progress;
          
          ctx.save();
          
          // Draw hit effect
          if (hitFeedback.type === 'critical') {
              // Critical hit effect (red burst)
              ctx.fillStyle = `rgba(255, 50, 50, ${opacity})`;
              ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
          } else {
              // Normal hit effect (white burst)
              ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
              ctx.strokeStyle = `rgba(200, 200, 200, ${opacity})`;
          }
          
          // Draw burst
          ctx.beginPath();
          ctx.arc(hitFeedback.x, hitFeedback.y, size / 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw impact lines
          ctx.lineWidth = 3;
          for (let i = 0; i < 8; i++) {
              const angle = Math.PI * 2 * i / 8;
              const innerRadius = size / 2;
              const outerRadius = size;
              
              ctx.beginPath();
              ctx.moveTo(
                  hitFeedback.x + Math.cos(angle) * innerRadius,
                  hitFeedback.y + Math.sin(angle) * innerRadius
              );
              ctx.lineTo(
                  hitFeedback.x + Math.cos(angle) * outerRadius,
                  hitFeedback.y + Math.sin(angle) * outerRadius
              );
              ctx.stroke();
          }
          
          ctx.restore();
      }

      // Draw hitboxes for debugging
      function drawHitboxes() {
          if (!players.player1 || !players.player2) return;
          
          const p1Hitbox = calculateHitboxes('player1');
          const p2Hitbox = calculateHitboxes('player2');
          
          if (!p1Hitbox || !p2Hitbox) return;
          
          ctx.save();
          
          // Draw player 1 hitboxes
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.lineWidth = 2;
          
          // Head
          ctx.beginPath();
          ctx.arc(p1Hitbox.head.x, p1Hitbox.head.y, p1Hitbox.head.radius, 0, Math.PI * 2);
          ctx.stroke();
          
          // Body
          ctx.strokeRect(
              p1Hitbox.body.x - p1Hitbox.body.width / 2,
              p1Hitbox.body.y - p1Hitbox.body.height / 2,
              p1Hitbox.body.width,
              p1Hitbox.body.height
          );
          
          // Attack point
          if (p1Hitbox.attackPoint.active) {
              ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
              ctx.beginPath();
              ctx.arc(p1Hitbox.attackPoint.x, p1Hitbox.attackPoint.y, 5, 0, Math.PI * 2);
              ctx.fill();
              
              // Draw attack range
              ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
              ctx.beginPath();
              ctx.arc(p1Hitbox.attackPoint.x, p1Hitbox.attackPoint.y, p1Hitbox.attackPoint.range, 0, Math.PI * 2);
              ctx.stroke();
          }
          
          // Draw player 2 hitboxes
          ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
          
          // Head
          ctx.beginPath();
          ctx.arc(p2Hitbox.head.x, p2Hitbox.head.y, p2Hitbox.head.radius, 0, Math.PI * 2);
          ctx.stroke();
          
          // Body
          ctx.strokeRect(
              p2Hitbox.body.x - p2Hitbox.body.width / 2,
              p2Hitbox.body.y - p2Hitbox.body.height / 2,
              p2Hitbox.body.width,
              p2Hitbox.body.height
          );
          
          // Attack point
          if (p2Hitbox.attackPoint.active) {
              ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';
              ctx.beginPath();
              ctx.arc(p2Hitbox.attackPoint.x, p2Hitbox.attackPoint.y, 5, 0, Math.PI * 2);
              ctx.fill();
              
              // Draw attack range
              ctx.strokeStyle = 'rgba(0, 0, 255, 0.3)';
              ctx.beginPath();
              ctx.arc(p2Hitbox.attackPoint.x, p2Hitbox.attackPoint.y, p2Hitbox.attackPoint.range, 0, Math.PI * 2);
              ctx.stroke();
          }
          
          ctx.restore();
      }
      
      function drawBackground() {
          // Sky gradient
          const skyGradient = ctx.createLinearGradient(0, 0, 0, gameHeight - 50);
          skyGradient.addColorStop(0, '#1a2a3a');
          skyGradient.addColorStop(1, '#3a4a5a');
          ctx.fillStyle = skyGradient;
          ctx.fillRect(0, 0, gameWidth, gameHeight - 50);
          
          // Draw distant mountains
          drawMountains();
          
          // Floor gradient with texture
          const floorGradient = ctx.createLinearGradient(0, gameHeight - 50, 0, gameHeight);
          floorGradient.addColorStop(0, '#554433');
          floorGradient.addColorStop(1, '#443322');
          ctx.fillStyle = floorGradient;
          ctx.fillRect(0, gameHeight - 50, gameWidth, 50);
          
          // Draw floor texture
          drawFloorTexture();
          
          // Draw floor edge highlight
          ctx.strokeStyle = '#665544';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, gameHeight - 50);
          ctx.lineTo(gameWidth, gameHeight - 50);
          ctx.stroke();
          
          // Draw some scattered rocks
          drawRocks();
      }

      function drawMountains() {
          ctx.fillStyle = '#2a3a4a';
          
          // First mountain range (far)
          ctx.beginPath();
          ctx.moveTo(0, gameHeight - 100);
          
          // Create a series of mountain peaks
          const peaks = 5;
          const peakWidth = gameWidth / peaks;
          
          for (let i = 0; i <= peaks; i++) {
              const x = i * peakWidth;
              const height = 30 + Math.random() * 40;
              
              if (i === 0) {
                  ctx.lineTo(x, gameHeight - 100);
              } else {
                  const cpx1 = x - peakWidth * 0.7;
                  const cpy1 = gameHeight - 100 - height * 0.3;
                  const cpx2 = x - peakWidth * 0.3;
                  const cpy2 = gameHeight - 100 - height * 0.7;
                  
                  ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, gameHeight - 100 - height);
                  
                  const cpx3 = x + peakWidth * 0.3;
                  const cpy3 = gameHeight - 100 - height * 0.7;
                  const cpx4 = x + peakWidth * 0.7;
                  const cpy4 = gameHeight - 100 - height * 0.3;
                  
                  ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x + peakWidth, gameHeight - 100);
              }
          }
          
          ctx.lineTo(gameWidth, gameHeight - 50);
          ctx.lineTo(0, gameHeight - 50);
          ctx.closePath();
          ctx.fill();
          
          // Second mountain range (closer, darker)
          ctx.fillStyle = '#1a2a3a';
          ctx.beginPath();
          ctx.moveTo(0, gameHeight - 70);
          
          const peaks2 = 7;
          const peakWidth2 = gameWidth / peaks2;
          
          for (let i = 0; i <= peaks2; i++) {
              const x = i * peakWidth2;
              const height = 20 + Math.random() * 30;
              
              if (i === 0) {
                  ctx.lineTo(x, gameHeight - 70);
              } else {
                  const cpx1 = x - peakWidth2 * 0.7;
                  const cpy1 = gameHeight - 70 - height * 0.3;
                  const cpx2 = x - peakWidth2 * 0.3;
                  const cpy2 = gameHeight - 70 - height * 0.7;
                  
                  ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, gameHeight - 70 - height);
                  
                  const cpx3 = x + peakWidth2 * 0.3;
                  const cpy3 = gameHeight - 70 - height * 0.7;
                  const cpx4 = x + peakWidth2 * 0.7;
                  const cpy4 = gameHeight - 70 - height * 0.3;
                  
                  ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x + peakWidth2, gameHeight - 70);
              }
          }
          
          ctx.lineTo(gameWidth, gameHeight - 50);
          ctx.lineTo(0, gameHeight - 50);
          ctx.closePath();
          ctx.fill();
      }

      function drawFloorTexture() {
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
          ctx.lineWidth = 1;
          
          // Draw horizontal texture lines
          for (let y = gameHeight - 45; y < gameHeight; y += 5) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(gameWidth, y);
              ctx.stroke();
          }
          
          // Draw some vertical cracks
          const cracks = 12;
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
          
          for (let i = 0; i < cracks; i++) {
              const x = Math.random() * gameWidth;
              const length = 5 + Math.random() * 15;
              const startY = gameHeight - 50 + Math.random() * 10;
              
              ctx.beginPath();
              ctx.moveTo(x, startY);
              
              // Create a jagged line for the crack
              let currentY = startY;
              const segments = 3 + Math.floor(Math.random() * 3);
              const segmentLength = length / segments;
              
              for (let j = 0; j < segments; j++) {
                  const nextX = x + (Math.random() * 6 - 3);
                  currentY += segmentLength;
                  ctx.lineTo(nextX, currentY);
              }
              
              ctx.stroke();
          }
      }

      function drawRocks() {
          // Draw some scattered rocks on the floor
          const rockCount = 8 + Math.floor(gameWidth / 100);
          
          for (let i = 0; i < rockCount; i++) {
              const x = Math.random() * gameWidth;
              const y = gameHeight - 50 + Math.random() * 10;
              const size = 2 + Math.random() * 4;
              
              // Don't draw rocks in the center area where players fight
              if (x > gameWidth * 0.4 && x < gameWidth * 0.6) continue;
              
              ctx.fillStyle = `rgba(100, 100, 100, ${0.3 + Math.random() * 0.4})`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill();
              
              // Add a highlight
              ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
              ctx.beginPath();
              ctx.arc(x - size * 0.3, y - size * 0.3, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
          }
      }
      
      function drawPlayers() {
          if (!players.player1 || !players.player2) return;
          
          // Calculate scale factor based on screen width to keep players visible
          const scaleFactor = Math.min(1, gameWidth / 800);
          const floorY = gameHeight - 50;
          
          // Adjust player positions for smaller screens
          const p1ScreenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, players.player1.x * scaleFactor));
          const p2ScreenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, players.player2.x * scaleFactor));
          
          // Draw player 1
          drawAnimatedStickman(
              p1ScreenX, 
              floorY - PLAYER_HEIGHT, 
              '#FF5555', 
              'player1', 
              false
          );
          
          // Draw player 2
          drawAnimatedStickman(
              p2ScreenX, 
              floorY - PLAYER_HEIGHT, 
              '#5555FF', 
              'player2', 
              true
          );
      }
      
      function drawAnimatedStickman(x, y, color, playerId, facingLeft) {
          const anim = playerAnimations[playerId];
          const state = anim.state;
          
          ctx.save();
          
          // Apply victory jump animation
          let yOffset = 0;
          if (state === VICTORY) {
              yOffset = -Math.abs(Math.sin(anim.victoryJump) * 20);
          }
          
          // Apply defeat fall animation
          if (state === DEFEAT) {
              // Rotate the entire stickman
              ctx.translate(x + PLAYER_WIDTH / 2, y + PLAYER_HEIGHT / 2);
              ctx.rotate(Math.PI / 2 * anim.defeatFall);
              ctx.translate(-(x + PLAYER_WIDTH / 2), -(y + PLAYER_HEIGHT / 2));
              
              // Add a falling effect
              yOffset = anim.defeatFall * 20;
          }
          
          // Apply hurt animation
          if (state === HURT) {
              // Rotate the entire stickman
              ctx.translate(x + PLAYER_WIDTH / 2, y + PLAYER_HEIGHT / 2);
              ctx.rotate(anim.hurtAngle);
              ctx.translate(-(x + PLAYER_WIDTH / 2), -(y + PLAYER_HEIGHT / 2));
          }
          
          // Flip if facing left
          if (facingLeft) {
              ctx.translate(x + PLAYER_WIDTH / 2, 0);
              ctx.scale(-1, 1);
              ctx.translate(-x - PLAYER_WIDTH / 2, 0);
          }
          
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Add breathing animation for idle
          let breatheOffset = 0;
          if (state === IDLE) {
              breatheOffset = anim.breatheOffset;
          }
          
          // Add walking animation
          let legOffset = 0;
          let armOffset = 0;
          if (state === WALKING) {
              legOffset = Math.sin(anim.walkCycle) * 10;
              armOffset = Math.sin(anim.walkCycle + Math.PI) * 5;
          }
          
          // Head with slight bobbing
          ctx.beginPath();
          ctx.arc(
              x + PLAYER_WIDTH / 2, 
              y + 10 + breatheOffset + yOffset, 
              10, 
              0, 
              Math.PI * 2
          );
          ctx.stroke();
          
          // Body with slight breathing movement
          ctx.beginPath();
          ctx.moveTo(
              x + PLAYER_WIDTH / 2, 
              y + 20 + breatheOffset + yOffset
          );
          ctx.lineTo(
              x + PLAYER_WIDTH / 2, 
              y + 50 + yOffset
          );
          ctx.stroke();
          
          // Arms based on state
          if (state === HITTING) {
              // Hitting pose with animation
              const hitExtension = Math.sin(animationFrame * 2) * 5;
              
              // Extended punching arm
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 5, y + 20 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH + 15 + hitExtension, y + 25 + yOffset);
              ctx.stroke();
              
              // Rear arm
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + 5, y + 40 + yOffset);
              ctx.stroke();
          } else if (state === KICKING) {
              // Kicking pose with animation
              // Arms in balance position
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 5, y + 25 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + 5, y + 25 + yOffset);
              ctx.stroke();
          } else if (state === VICTORY) {
              // Victory pose - arms up
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 5, y + 15 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH, y + 5 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + 5, y + 15 + yOffset);
              ctx.lineTo(x, y + 5 + yOffset);
              ctx.stroke();
          } else if (state === DEFEAT) {
              // Defeat pose - limp arms
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 5, y + 45 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + 5, y + 45 + yOffset);
              ctx.stroke();
          } else {
              // Normal or walking pose
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 5 + armOffset, y + 25 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 30 + yOffset);
              ctx.lineTo(x + 5 - armOffset, y + 25 + yOffset);
              ctx.stroke();
          }
          
          // Legs based on state
          if (state === KICKING) {
              // Kicking pose with animation
              const kickExtension = Math.sin(animationFrame * 2) * 5;
              
              // Standing leg
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + 10, y + 70 + yOffset);
              ctx.stroke();
              
              // Kicking leg
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH + 20 + kickExtension, y + 60 + yOffset);
              ctx.stroke();
          } else if (state === VICTORY) {
              // Victory pose - slight bounce in legs
              const bounce = Math.sin(anim.victoryJump * 2) * 3;
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + 10 - bounce, y + 70 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 10 + bounce, y + 70 + yOffset);
              ctx.stroke();
          } else if (state === DEFEAT) {
              // Defeat pose - limp legs
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + 10, y + 60 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 10, y + 60 + yOffset);
              ctx.stroke();
          } else if (state === WALKING) {
              // Walking animation
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + 10 + legOffset, y + 70 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 10 - legOffset, y + 70 + yOffset);
              ctx.stroke();
          } else {
              // Normal pose
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + 10, y + 70 + yOffset);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(x + PLAYER_WIDTH / 2, y + 50 + yOffset);
              ctx.lineTo(x + PLAYER_WIDTH - 10, y + 70 + yOffset);
              ctx.stroke();
          }
          
          // If hurt, draw stars around head
          if (state === HURT) {
              ctx.strokeStyle = 'yellow';
              for (let i = 0; i < 3; i++) {
                  const angle = Math.PI * 2 * i / 3 + animationFrame;
                  const distance = 20 + Math.sin(animationFrame) * 5;
                  const starX = x + PLAYER_WIDTH / 2 + Math.cos(angle) * distance;
                  const starY = y + 10 + Math.sin(angle) * distance + yOffset;
                  
                  // Draw animated stars
                  const starSize = 5 + Math.sin(animationFrame * 2 + i) * 2;
                  
                  ctx.beginPath();
                  ctx.moveTo(starX - starSize, starY);
                  ctx.lineTo(starX + starSize, starY);
                  ctx.stroke();
                  
                  ctx.beginPath();
                  ctx.moveTo(starX, starY - starSize);
                  ctx.lineTo(starX, starY + starSize);
                  ctx.stroke();
              }
          }
          
          // Draw victory sparkles
          if (state === VICTORY) {
              ctx.strokeStyle = 'gold';
              for (let i = 0; i < 5; i++) {
                  const angle = Math.PI * 2 * i / 5 + animationFrame * 0.5;
                  const distance = 30 + Math.sin(animationFrame + i) * 10;
                  const sparkleX = x + PLAYER_WIDTH / 2 + Math.cos(angle) * distance;
                  const sparkleY = y + 30 + Math.sin(angle) * distance + yOffset;
                  
                  // Draw animated sparkles
                  const sparkleSize = 3 + Math.sin(animationFrame * 3 + i) * 2;
                  
                  // Draw a star shape
                  ctx.beginPath();
                  for (let j = 0; j < 5; j++) {
                      const starAngle = Math.PI * 2 * j / 5 + animationFrame;
                      const starX = sparkleX + Math.cos(starAngle) * sparkleSize;
                      const starY = sparkleY + Math.sin(starAngle) * sparkleSize;
                      
                      if (j === 0) {
                          ctx.moveTo(starX, starY);
                      } else {
                          ctx.lineTo(starX, starY);
                      }
                  }
                  ctx.closePath();
                  ctx.stroke();
              }
          }
          
          ctx.restore();
      }
      
      function drawPowerBars() {
          if (!players.player1 || !players.player2) return;
          
          const barHeight = 15;
          const margin = 10;
          
          // Responsive bar width based on screen size
          const barWidth = Math.min(200, (gameWidth / 2) - 20);
          
          // Player 1 power bar
          ctx.fillStyle = '#333';
          ctx.fillRect(margin, margin, barWidth, barHeight);
          
          // Animate power bar when taking damage
          let p1PowerWidth = (players.player1.power / MAX_POWER) * barWidth;
          
          // Add pulsing effect when low health
          if (players.player1.power < MAX_POWER * 0.3) {
              const pulse = Math.sin(animationFrame * 2) * 0.1 + 0.9;
              ctx.fillStyle = `rgba(255, 85, 85, ${pulse})`;
          } else {
              ctx.fillStyle = '#FF5555';
          }
          
          ctx.fillRect(margin, margin, p1PowerWidth, barHeight);
          
          ctx.strokeStyle = '#FFF';
          ctx.strokeRect(margin, margin, barWidth, barHeight);
          
          ctx.fillStyle = '#FFF';
          ctx.font = '12px Arial';
          ctx.fillText('Player 1', margin, margin + barHeight + 12);
          
          // Player 2 power bar
          ctx.fillStyle = '#333';
          ctx.fillRect(gameWidth - margin - barWidth, margin, barWidth, barHeight);
          
          // Animate power bar when taking damage
          let p2PowerWidth = (players.player2.power / MAX_POWER) * barWidth;
          
          // Add pulsing effect when low health
          if (players.player2.power < MAX_POWER * 0.3) {
              const pulse = Math.sin(animationFrame * 2) * 0.1 + 0.9;
              ctx.fillStyle = `rgba(85, 85, 255, ${pulse})`;
          } else {
              ctx.fillStyle = '#5555FF';
          }
          
          ctx.fillRect(gameWidth - margin - p2PowerWidth, margin, p2PowerWidth, barHeight);
          
          ctx.strokeStyle = '#FFF';
          ctx.strokeRect(gameWidth - margin - barWidth, margin, barWidth, barHeight);
          
          ctx.fillStyle = '#FFF';
          ctx.font = '12px Arial';
          ctx.fillText('Player 2', gameWidth - margin - barWidth, margin + barHeight + 12);
      }
      
      function showWinner(winner) {
          const winnerMessage = document.getElementById('winnerMessage');
          
          // Don't show the message if it's already visible
          if (winnerMessage.style.display === 'block') return;
          
          const winnerText = document.getElementById('winnerText');
          
          // Format winner text nicely
          winnerText.textContent = `${winner === 'player1' ? 'Player 1' : 'Player 2'} wins!`;
          winnerMessage.style.display = 'block';
          
          // Play victory sound
          playSound('victory');
          
          // Reset ready status indicators
          document.getElementById('player1Status').className = 'status-indicator status-waiting';
          document.getElementById('player1Status').textContent = 'Player 1: Waiting';
          document.getElementById('player2Status').className = 'status-indicator status-waiting';
          document.getElementById('player2Status').textContent = 'Player 2: Waiting';
          
          // Reset restart button
          const restartBtn = document.getElementById('restartBtn');
          restartBtn.textContent = 'Play Again';
          restartBtn.disabled = false;
          
          // Clear ready players array
          readyPlayers = [];
          
          // Ensure animations continue to run
          if (winner === 'player1') {
              playerAnimations.player1.state = VICTORY;
              playerAnimations.player2.state = DEFEAT;
          } else {
              playerAnimations.player2.state = VICTORY;
              playerAnimations.player1.state = DEFEAT;
          }
          
          // Reset hit feedback
          hitFeedback.active = false;
      }
  </script>
</body>
</html>
