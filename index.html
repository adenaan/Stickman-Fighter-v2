<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stickman Fighter</title>
  <!-- Load Socket.io from CDN -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          touch-action: none;
          background-color: #222;
          font-family: Arial, sans-serif;
      }
      #gameContainer {
          position: relative;
          width: 100vw;
          height: 100vh;
          overflow: hidden;
      }
      #gameCanvas {
          background-color: #333;
          position: absolute;
          top: 0;
          left: 0;
      }
      .controls {
          position: fixed;
          bottom: 30px; /* Increased from 20px to move controls lower */
          width: 100%;
          padding: 0 10px;
          box-sizing: border-box;
          z-index: 10;
          display: flex;
          justify-content: center;
      }
      .player-controls {
          display: flex;
          gap: 12px;
          margin-bottom: 15px; /* Extra margin at the bottom */
      }
      .control-btn {
          width: 65px;
          height: 65px;
          border-radius: 50%;
          border: none;
          background-color: rgba(255, 255, 255, 0.3);
          color: white;
          font-weight: bold;
          font-size: 18px;
          touch-action: manipulation;
          user-select: none;
          -webkit-user-select: none;
          /* Add transition for smooth feedback */
          transition: all 0.1s ease;
          position: relative;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      /* Button press effect */
      .control-btn.active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
      }
      @media (max-width: 480px) {
          .control-btn {
              width: 55px;
              height: 55px;
              font-size: 16px;
          }
          .player-controls {
              gap: 10px;
          }
      }
      @media (max-width: 360px) {
          .control-btn {
              width: 45px;
              height: 45px;
              font-size: 14px;
          }
          .player-controls {
              gap: 8px;
          }
      }
      .hit-btn {
          background-color: rgba(255, 50, 50, 0.7);
      }
      .hit-btn.active {
          background-color: rgba(255, 50, 50, 0.9);
      }
      .kick-btn {
          background-color: rgba(50, 50, 255, 0.7);
      }
      .kick-btn.active {
          background-color: rgba(50, 50, 255, 0.9);
      }
      .move-btn {
          background-color: rgba(50, 200, 50, 0.7);
      }
      .move-btn.active {
          background-color: rgba(50, 200, 50, 0.9);
      }
      /* Button ripple effect */
      .control-btn::after {
          content: '';
          position: absolute;
          top: 50%;
          left: 50%;
          width: 5px;
          height: 5px;
          background: rgba(255, 255, 255, 0.5);
          opacity: 0;
          border-radius: 100%;
          transform: scale(1, 1) translate(-50%, -50%);
          transform-origin: 50% 50%;
      }
      .control-btn.active::after {
          animation: ripple 0.4s ease-out;
      }
      @keyframes ripple {
          0% {
              transform: scale(0, 0) translate(-50%, -50%);
              opacity: 0.5;
          }
          100% {
              transform: scale(20, 20) translate(-50%, -50%);
              opacity: 0;
          }
      }
      #winnerMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 30px;
          border-radius: 10px;
          font-size: 24px;
          display: none;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #restartBtn {
          margin-top: 20px;
          padding: 15px 30px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 18px;
          touch-action: manipulation;
          transition: all 0.1s ease;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      #restartBtn:active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
          background-color: #3e8e41;
      }
      #restartBtn:disabled {
          background-color: #888;
          cursor: default;
          transform: none;
          box-shadow: none;
      }
      #waitingMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 20px;
          border-radius: 10px;
          font-size: 20px;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #playerIndicator {
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 16px;
          z-index: 30;
          text-align: center;
      }
      #debugInfo {
          position: fixed;
          top: 40px;
          left: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          font-size: 12px;
          z-index: 30;
          display: none;
      }
      /* Add a game area container to help with positioning */
      #gameArea {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: calc(100% - 130px); /* Reserve space for controls */
          overflow: hidden;
      }
      /* Player ready status styles */
      .player-status {
          margin-top: 10px;
          display: flex;
          justify-content: space-between;
          width: 100%;
      }
      .status-indicator {
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
      }
      .status-waiting {
          color: #ff5555;
      }
      .status-ready {
          color: #55ff55;
      }
      /* Sound control styles */
      #soundControl {
          position: fixed;
          top: 10px;
          right: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          z-index: 30;
          cursor: pointer;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
      }
      /* Weather and background controls */
      #visualControls {
          position: fixed;
          top: 10px;
          left: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          z-index: 30;
          cursor: pointer;
          display: flex;
          flex-direction: column;
          gap: 5px;
          font-size: 12px;
      }
      .visual-control-btn {
          padding: 3px 6px;
          background-color: rgba(255, 255, 255, 0.2);
          border: none;
          border-radius: 3px;
          color: white;
          cursor: pointer;
          transition: all 0.1s ease;
      }
      .visual-control-btn:hover {
          background-color: rgba(255, 255, 255, 0.3);
      }
      .visual-control-btn.active {
          background-color: rgba(100, 200, 100, 0.5);
      }
      .visual-control-group {
          margin-bottom: 5px;
      }
      .visual-control-label {
          margin-bottom: 3px;
          font-weight: bold;
      }
  </style>
</head>
<body>
  <div id="gameContainer">
      <div id="playerIndicator"></div>
      <div id="debugInfo"></div>
      <div id="soundControl">🔊</div>
      
      <div id="visualControls">
          <div class="visual-control-group">
              <div class="visual-control-label">Background</div>
              <button class="visual-control-btn" data-bg="dojo">Dojo</button>
              <button class="visual-control-btn" data-bg="mountain">Mountain</button>
              <button class="visual-control-btn" data-bg="city">City</button>
              <button class="visual-control-btn" data-bg="beach">Beach</button>
              <button class="visual-control-btn" data-bg="forest">Forest</button>
          </div>
          <div class="visual-control-group">
              <div class="visual-control-label">Weather</div>
              <button class="visual-control-btn" data-weather="none">Clear</button>
              <button class="visual-control-btn" data-weather="rain">Rain</button>
              <button class="visual-control-btn" data-weather="snow">Snow</button>
              <button class="visual-control-btn" data-weather="storm">Storm</button>
              <button class="visual-control-btn" data-weather="fog">Fog</button>
          </div>
          <div class="visual-control-group">
              <div class="visual-control-label">Time</div>
              <button class="visual-control-btn" data-time="day">Day</button>
              <button class="visual-control-btn" data-time="sunset">Sunset</button>
              <button class="visual-control-btn" data-time="night">Night</button>
              <button class="visual-control-btn" data-time="dawn">Dawn</button>
          </div>
          <div class="visual-control-group">
              <div class="visual-control-label">Auto Cycle</div>
              <button class="visual-control-btn" id="toggleBgCycle">BG: Off</button>
              <button class="visual-control-btn" id="toggleWeatherCycle">Weather: Off</button>
          </div>
      </div>
      
      <div id="gameArea">
          <canvas id="gameCanvas"></canvas>
      </div>
      
      <div class="controls" id="controlsContainer">
          <!-- Control buttons will be added here dynamically -->
      </div>
      
      <div id="winnerMessage">
          <div id="winnerText"></div>
          <div class="player-status">
              <div id="player1Status" class="status-indicator status-waiting">Player 1: Waiting</div>
              <div id="player2Status" class="status-indicator status-waiting">Player 2: Waiting</div>
          </div>
          <button id="restartBtn">Play Again</button>
      </div>
      
      <div id="waitingMessage">
          Connecting to server...
      </div>
  </div>

  <script>
      // Game variables
      let canvas, ctx;
      let gameWidth, gameHeight;
      let socket;
      let playerId;
      let players = {};
      let gameStarted = false;
      let readyPlayers = []; // Track which players are ready
      let gameState = {};
      let gameEnding = false; // Flag to track if the game is in the ending sequence
      let gameEndTime = 0; // Time when the game ended
      let winnerAnnounced = false; // Flag to track if the winner has been announced

      // Hit detection variables
      let lastHitTime = 0;
      let hitFeedback = {
          active: false,
          x: 0,
          y: 0,
          type: '',
          time: 0
      };

      const GLITCH_SERVER_URL = "https://stickmanfightingnew.glitch.me";
      
      // Sound variables
      let soundEnabled = true;
      let sounds = {};
      let soundsLoaded = false;
      
      // Game constants
      const PLAYER_WIDTH = 30;
      const PLAYER_HEIGHT = 80;
      const PLAYER_SPEED = 5;
      const MAX_POWER = 100;
      const HIT_DAMAGE = 10;
      const KICK_DAMAGE = 15;
      const HIT_RANGE = 40;
      const KICK_RANGE = 50;
      const GAME_END_DELAY = 1500; // Delay before showing winner message (ms)

      // Hit detection constants
      const HEAD_HITBOX_RADIUS = 10;
      const BODY_HITBOX_WIDTH = 20;
      const BODY_HITBOX_HEIGHT = 30;
      const ARM_HITBOX_WIDTH = 30;
      const LEG_HITBOX_WIDTH = 30;
      const CRITICAL_HIT_MULTIPLIER = 1.5;
      const HIT_COOLDOWN = 300; // ms
      const HIT_FEEDBACK_DURATION = 200; // ms
      
      // Animation states
      const IDLE = 'idle';
      const HITTING = 'hitting';
      const KICKING = 'kicking';
      const HURT = 'hurt';
      const WALKING = 'walking';
      const VICTORY = 'victory';
      const DEFEAT = 'defeat';
      
      // Animation variables
      let animationFrame = 0;
      const ANIMATION_SPEED = 0.1; // Lower is slower
      let lastTime = 0;
      
      // Animation data for each player
      const playerAnimations = {
          player1: {
              state: IDLE,
              frame: 0,
              breatheOffset: 0,
              breatheDirection: 1,
              walkCycle: 0,
              hurtAngle: 0,
              hurtDirection: 1,
              victoryJump: 0,
              defeatFall: 0
          },
          player2: {
              state: IDLE,
              frame: 0,
              breatheOffset: 0,
              breatheDirection: 1,
              walkCycle: 0,
              hurtAngle: 0,
              hurtDirection: -1,
              victoryJump: 0,
              defeatFall: 0
          }
      };

      // Weather and background systems
      let weatherSystem;
      let backgroundManager;
      
      // Debug function
      function debug(message) {
          const debugElement = document.getElementById('debugInfo');
          debugElement.style.display = 'block';
          debugElement.textContent = message;
          console.log(message);
      }
      
      // Initialize the game
      window.onload = function() {
          canvas = document.getElementById('gameCanvas');
          ctx = canvas.getContext('2d');
          
          // Set canvas size
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          
          // Load sounds
          loadSounds();
          
          // Set up sound control
          setupSoundControl();
          
          // Initialize visual systems (weather and background)
          initializeVisualSystems();
          
          // Set up visual controls
          setupVisualControls();
          
          // Connect to server automatically
          connectToServer();
          
          // Set up restart button with multiple event types
          setupRestartButton();
          
          // Start game loop
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
      };
      
      // Load all game sounds
      function loadSounds() {
          const soundFiles = {
              hit: '/Stickman-Fighter-v2/assets/punch.mp3',
              kick: '/Stickman-Fighter-v2/assets/kick.mp3',
              hurt: '/Stickman-Fighter-v2/assets/hurt.mp3',
              victory: '/Stickman-Fighter-v2/assets/victory.mp3',
              gameStart: '/Stickman-Fighter-v2/assets/game-start.mp3',
              button: '/Stickman-Fighter-v2/assets/button-press.mp3',
              thunder: '/Stickman-Fighter-v2/assets/thunder.mp3'
          };
          
          let loadedCount = 0;
          const totalSounds = Object.keys(soundFiles).length;
          
          // Create audio objects for each sound
          for (const [name, url] of Object.entries(soundFiles)) {
              sounds[name] = new Audio();
              sounds[name].src = url;
              
              // Handle loading
              sounds[name].addEventListener('canplaythrough', () => {
                  loadedCount++;
                  if (loadedCount === totalSounds) {
                      soundsLoaded = true;
                      console.log('All sounds loaded');
                  }
              });
              
              // Handle errors
              sounds[name].addEventListener('error', (e) => {
                  console.error(`Error loading sound ${name}:`, e);
              });
              
              // Preload the sound
              sounds[name].load();
          }
      }
      
      // Play a sound with error handling
      function playSound(name) {
          if (!soundEnabled || !soundsLoaded) return;
          
          try {
              // Create a clone to allow overlapping sounds
              const sound = sounds[name].cloneNode();
              sound.volume = 0.5; // Set volume to 50%
              
              // Play the sound with a promise and catch any errors
              const playPromise = sound.play();
              
              if (playPromise !== undefined) {
                  playPromise.catch(error => {
                      console.warn(`Sound play error (${name}):`, error);
                  });
              }
          } catch (error) {
              console.error(`Error playing sound ${name}:`, error);
          }
      }
      
      // Set up sound control button
      function setupSoundControl() {
          const soundControl = document.getElementById('soundControl');
          
          soundControl.addEventListener('click', function() {
              soundEnabled = !soundEnabled;
              this.textContent = soundEnabled ? '🔊' : '🔇';
              
              // Play a sound to confirm it's working
              if (soundEnabled) {
                  playSound('button');
              }
          });
      }
      
      function resizeCanvas() {
          // Get the gameArea dimensions
          const gameArea = document.getElementById('gameArea');
          gameWidth = gameArea.clientWidth;
          gameHeight = gameArea.clientHeight;
          
          canvas.width = gameWidth;
          canvas.height = gameHeight;
      }

      // Initialize weather and background systems
      function initializeVisualSystems() {
          // Initialize weather system
          weatherSystem = new WeatherSystem(canvas, ctx);
          weatherSystem.init();

          // Initialize background manager
          backgroundManager = new BackgroundManager(canvas, ctx);
          backgroundManager.init().then(() => {
              console.log("Background manager ready");
              
              // Start with a random background
              const backgrounds = ["dojo", "mountain", "city", "beach", "forest"];
              const randomBg = backgrounds[Math.floor(Math.random() * backgrounds.length)];
              backgroundManager.setBackground(randomBg, false);
          });

          // Make playSound function available to weather system
          window.playSound = playSound;
          window.soundEnabled = soundEnabled;
      }

      // Set up visual controls
      function setupVisualControls() {
          // Background buttons
          document.querySelectorAll('.visual-control-btn[data-bg]').forEach(btn => {
              btn.addEventListener('click', function() {
                  const bg = this.getAttribute('data-bg');
                  if (backgroundManager) {
                      backgroundManager.setBackground(bg);
                      
                      // Update active state
                      document.querySelectorAll('.visual-control-btn[data-bg]').forEach(b => {
                          b.classList.remove('active');
                      });
                      this.classList.add('active');
                      
                      // Play button sound
                      playSound('button');
                  }
              });
          });
          
          // Weather buttons
          document.querySelectorAll('.visual-control-btn[data-weather]').forEach(btn => {
              btn.addEventListener('click', function() {
                  const weather = this.getAttribute('data-weather');
                  if (weatherSystem) {
                      weatherSystem.setWeather(weather);
                      
                      // Update active state
                      document.querySelectorAll('.visual-control-btn[data-weather]').forEach(b => {
                          b.classList.remove('active');
                      });
                      this.classList.add('active');
                      
                      // Play button sound
                      playSound('button');
                  }
              });
          });
          
          // Time of day buttons
          document.querySelectorAll('.visual-control-btn[data-time]').forEach(btn => {
              btn.addEventListener('click', function() {
                  const time = this.getAttribute('data-time');
                  if (backgroundManager) {
                      backgroundManager.setTimeOfDay(time);
                      
                      // Update active state
                      document.querySelectorAll('.visual-control-btn[data-time]').forEach(b => {
                          b.classList.remove('active');
                      });
                      this.classList.add('active');
                      
                      // Play button sound
                      playSound('button');
                  }
              });
          });
          
          // Background auto cycle toggle
          const toggleBgCycleBtn = document.getElementById('toggleBgCycle');
          toggleBgCycleBtn.addEventListener('click', function() {
              if (backgroundManager) {
                  if (backgroundManager.autoCycle) {
                      backgroundManager.disableAutoCycle();
                      this.textContent = 'BG: Off';
                      this.classList.remove('active');
                  } else {
                      backgroundManager.enableAutoCycle(60000); // Change every 60 seconds
                      this.textContent = 'BG: On';
                      this.classList.add('active');
                  }
                  
                  // Play button sound
                  playSound('button');
              }
          });
          
          // Weather auto cycle toggle
          const toggleWeatherCycleBtn = document.getElementById('toggleWeatherCycle');
          toggleWeatherCycleBtn.addEventListener('click', function() {
              if (weatherSystem) {
                  if (weatherSystem.autoCycle) {
                      weatherSystem.disableAutoCycle();
                      this.textContent = 'Weather: Off';
                      this.classList.remove('active');
                  } else {
                      weatherSystem.enableAutoCycle(30000); // Change every 30 seconds
                      this.textContent = 'Weather: On';
                      this.classList.add('active');
                  }
                  
                  // Play button sound
                  playSound('button');
              }
          });
          
          // Set initial active states
          document.querySelector('.visual-control-btn[data-bg="dojo"]').classList.add('active');
          document.querySelector('.visual-control-btn[data-weather="none"]').classList.add('active');
          document.querySelector('.visual-control-btn[data-time="day"]').classList.add('active');
      }
      
      function connectToServer() {
          try {
              // Connect to the hardcoded Glitch server
              socket = io(GLITCH_SERVER_URL, {
                  transports: ['websocket', 'polling'],
                  reconnectionAttempts: 5
              });
              
              socket.on('connect', function() {
                  console.log('Connected to server');
                  document.getElementById('waitingMessage').textContent = 'Waiting for another player to join...';
              });
              
              socket.on('connect_error', function(error) {
                  console.error('Connection error:', error);
                  document.getElementById('waitingMessage').textContent = 'Connection error. Please try again.';
                  // Try to reconnect after 3 seconds
                  setTimeout(connectToServer, 3000);
              });
              
              socket.on('playerId', function(id) {
                  playerId = id;
                  console.log('Your player ID:', playerId);
                  
                  // Show player indicator
                  document.getElementById('playerIndicator').textContent = 
                      id === 'player1' ? 'You are Player 1 (Red)' : 'You are Player 2 (Blue)';
                  
                  // Set up controls for this player
                  setupPlayerControls();
              });
              
              socket.on('gameState', function(state) {
                  // Track previous player states to detect changes for sound effects
                  const prevPlayer1State = players.player1 ? players.player1.state : null;
                  const prevPlayer2State = players.player2 ? players.player2.state : null;
                  const prevPlayer1Power = players.player1 ? players.player1.power : MAX_POWER;
                  const prevPlayer2Power = players.player2 ? players.player2.power : MAX_POWER;
                  const wasGameStarted = gameStarted;
                  
                  // Store the previous winner
                  const prevWinner = gameState.winner;
                  
                  // Update game state
                  players = state.players;
                  gameStarted = state.gameStarted;
                  gameState = state;
                  
                  // Add isMoving property if it doesn't exist
                  if (players.player1 && players.player1.isMoving === undefined) {
                      players.player1.isMoving = false;
                  }
                  if (players.player2 && players.player2.isMoving === undefined) {
                      players.player2.isMoving = false;
                  }
                  
                  // Check if a player's health just reached zero
                  const player1Defeated = prevPlayer1Power > 0 && players.player1.power <= 0;
                  const player2Defeated = prevPlayer2Power > 0 && players.player2.power <= 0;

                  // If a player was just defeated, start the game ending sequence
                  if ((player1Defeated || player2Defeated) && !gameEnding) {
                      gameEnding = true;
                      gameEndTime = performance.now();
                      
                      // Set victory/defeat animations immediately
                      if (player1Defeated) {
                          playerAnimations.player1.state = DEFEAT;
                          playerAnimations.player2.state = VICTORY;
                          
                          // Immediately show winner message without delay
                          showWinner('player2');
                          winnerAnnounced = true;
                      } else if (player2Defeated) {
                          playerAnimations.player1.state = VICTORY;
                          playerAnimations.player2.state = DEFEAT;
                          
                          // Immediately show winner message without delay
                          showWinner('player1');
                          winnerAnnounced = true;
                      }
                      
                      // Play hurt sound for the defeated player
                      if (player1Defeated) {
                          playSound('hurt');
                      } else if (player2Defeated) {
                          playSound('hurt');
                      }
                      
                      console.log("Game ending sequence started");
                  }
                  
                  // Update animation states based on player states
                  if (players.player1 && !gameEnding) {
                      updateAnimationState('player1', players.player1.state, players.player1.isMoving);
                  }
                  if (players.player2 && !gameEnding) {
                      updateAnimationState('player2', players.player2.state, players.player2.isMoving);
                  }
                  
                  // Play game start sound when game begins
                  if (gameStarted && !wasGameStarted) {
                      playSound('gameStart');
                  }
                  
                  // Play sounds based on state changes
                  if (players.player1 && prevPlayer1State !== players.player1.state && !gameEnding) {
                      if (players.player1.state === HITTING) playSound('hit');
                      if (players.player1.state === KICKING) playSound('kick');
                      if (players.player1.state === HURT) playSound('hurt');
                  }
                  
                  if (players.player2 && prevPlayer2State !== players.player2.state && !gameEnding) {
                      if (players.player2.state === HITTING) playSound('hit');
                      if (players.player2.state === KICKING) playSound('kick');
                      if (players.player2.state === HURT) playSound('hurt');
                  }
                  
                  // Show/hide waiting message
                  document.getElementById('waitingMessage').style.display = 
                      gameStarted ? 'none' : 'block';
                  
                  // Check for winner
                  if (state.winner && !prevWinner) {
                      // Winner was just determined
                      console.log(`Winner determined: ${state.winner}`);
                      
                      // Start the game ending sequence if it hasn't already started
                      if (!gameEnding) {
                          gameEnding = true;
                          gameEndTime = performance.now();
                          
                          // Set victory/defeat animations immediately
                          if (state.winner === 'player1') {
                              playerAnimations.player1.state = VICTORY;
                              playerAnimations.player2.state = DEFEAT;
                          } else {
                              playerAnimations.player1.state = DEFEAT;
                              playerAnimations.player2.state = VICTORY;
                          }
                          
                          // Play victory sound
                          playSound('victory');
                      }
                  } else if (state.winner === null && prevWinner) {
                      // Game has been reset
                      resetGameState();
                  }
              });
              
              // Listen for player ready status updates
              socket.on('playerReady', function(players) {
                  readyPlayers = players;
                  updateReadyStatus();
                  
                  debug("Ready players: " + JSON.stringify(readyPlayers));
                  
                  // If this player is ready, update button state
                  if (readyPlayers.includes(playerId)) {
                      const restartBtn = document.getElementById('restartBtn');
                      restartBtn.textContent = 'Waiting for other player...';
                      restartBtn.disabled = true;
                  }
                  
                  // Play button sound when a player gets ready
                  playSound('button');
                  
                  // Check if both players are ready
                  if (readyPlayers.includes('player1') && readyPlayers.includes('player2')) {
                      debug("Both players ready, restarting game");
                      
                      // Hide winner message
                      document.getElementById('winnerMessage').style.display = 'none';
                      
                      // Reset game state locally
                      resetGameState();
                      
                      // Tell the server to restart the game
                      socket.emit('restartGame');
                  }
              });

              // Add a new socket event handler for game restart confirmation
              socket.on('gameRestarted', function() {
                  debug("Game has been restarted by server");
                  
                  // Hide winner message if it's still showing
                  document.getElementById('winnerMessage').style.display = 'none';
                  
                  // Reset game state
                  resetGameState();
                  
                  // Play game start sound
                  playSound('gameStart');
              });
          } catch (error) {
              console.error('Error connecting to server:', error);
              document.getElementById('waitingMessage').textContent = 'Failed to connect to server. Please try again.';
              // Try to reconnect after 3 seconds
              setTimeout(connectToServer, 3000);
          }
      }
      
      // Reset game state when a new game starts
      function resetGameState() {
          console.log("Resetting game state");
          
          // Hide winner message
          document.getElementById('winnerMessage').style.display = 'none';
          
          // Reset button state
          const restartBtn = document.getElementById('restartBtn');
          restartBtn.textContent = 'Play Again';
          restartBtn.disabled = false;
          
          // Reset player status indicators
          document.getElementById('player1Status').className = 'status-indicator status-waiting';
          document.getElementById('player1Status').textContent = 'Player 1: Waiting';
          document.getElementById('player2Status').className = 'status-indicator status-waiting';
          document.getElementById('player2Status').textContent = 'Player 2: Waiting';
          
          // Clear ready players array
          readyPlayers = [];
          
          // Reset animation states
          playerAnimations.player1.state = IDLE;
          playerAnimations.player2.state = IDLE;
          
          // Reset game ending flags
          gameEnding = false;
          gameEndTime = 0;
          winnerAnnounced = false;
          
          // Reset hit feedback
          hitFeedback.active = false;
      }
      
      // Update animation state based on player state
      function updateAnimationState(playerId, state, isMoving) {
          const anim = playerAnimations[playerId];
          
          // Don't update if we're in the game ending sequence
          if (gameEnding) return;
          
          // Only update if state changed
          if (anim.state !== state) {
              anim.frame = 0; // Reset animation frame on state change
              
              // Reset specific animation variables
              if (state === HURT) {
                  anim.hurtAngle = 0;
                  anim.hurtDirection = playerId === 'player1' ? 1 : -1;
              }
          }
          
          // Set the animation state
          anim.state = state;
          
          // Handle walking state
          if (isMoving && state === IDLE) {
              anim.state = WALKING;
          }
      }
      
      function updateReadyStatus() {
          // Update player 1 status
          const player1Status = document.getElementById('player1Status');
          if (readyPlayers.includes('player1')) {
              player1Status.className = 'status-indicator status-ready';
              player1Status.textContent = 'Player 1: Ready';
          } else {
              player1Status.className = 'status-indicator status-waiting';
              player1Status.textContent = 'Player 1: Waiting';
          }
          
          // Update player 2 status
          const player2Status = document.getElementById('player2Status');
          if (readyPlayers.includes('player2')) {
              player2Status.className = 'status-indicator status-ready';
              player2Status.textContent = 'Player 2: Ready';
          } else {
              player2Status.className = 'status-indicator status-waiting';
              player2Status.textContent = 'Player 2: Waiting';
          }
      }
      
      function setupPlayerControls() {
          const controlsContainer = document.getElementById('controlsContainer');
          
          // Clear any existing controls
          controlsContainer.innerHTML = '';
          
          // Create new control container
          const playerControls = document.createElement('div');
          playerControls.className = 'player-controls';
          playerControls.innerHTML = `
              <button class="control-btn move-btn" id="moveLeft">←</button>
              <button class="control-btn move-btn" id="moveRight">→</button>
              <button class="control-btn hit-btn" id="hitBtn">HIT</button>
              <button class="control-btn kick-btn" id="kickBtn">KICK</button>
          `;
          
          controlsContainer.appendChild(playerControls);
          
          // Setup touch event listeners
          setupControlEventListeners();
      }
      
      function setupControlEventListeners() {
          // Get all control buttons
          const moveLeftBtn = document.getElementById('moveLeft');
          const moveRightBtn = document.getElementById('moveRight');
          const hitBtn = document.getElementById('hitBtn');
          const kickBtn = document.getElementById('kickBtn');
          
          // Clear any existing event listeners (just in case)
          moveLeftBtn.replaceWith(moveLeftBtn.cloneNode(true));
          moveRightBtn.replaceWith(moveRightBtn.cloneNode(true));
          hitBtn.replaceWith(hitBtn.cloneNode(true));
          kickBtn.replaceWith(kickBtn.cloneNode(true));
          
          // Get the fresh elements
          const newMoveLeftBtn = document.getElementById('moveLeft');
          const newMoveRightBtn = document.getElementById('moveRight');
          const newHitBtn = document.getElementById('hitBtn');
          const newKickBtn = document.getElementById('kickBtn');
          
          // Add touch start event listeners
          newMoveLeftBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'hit'});
          });
          
          newKickBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'kick'});
          });
          
          // Add touch end event listeners
          newMoveLeftBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          // For mouse users (testing)
          newMoveLeftBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'hit'});
          });
          
          newKickBtn.addEventListener('mousedown', function(e) {
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'kick'});
          });
          
          newMoveLeftBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          // Setup keyboard controls
          setupKeyboardControls();
      }
      
      function setupKeyboardControls() {
          // Remove any existing event listeners
          window.removeEventListener('keydown', handleKeyDown);
          
          window.removeEventListener('keyup', handleKeyUp);
          
          // Add event listeners
          window.addEventListener('keydown', handleKeyDown);
          window.addEventListener('keyup', handleKeyUp);
      }
      
      function handleKeyDown(e) {
          if (!socket || !playerId || gameEnding) return;
          
          let buttonId = null;
          let command = null;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
          }
          
          // Add active class to the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button && !button.classList.contains('active')) {
                  button.classList.add('active');
              }
              
              // Send command to server
              if (command) {
                  if (command.type === 'move') {
                      socket.emit('move', command.data);
                  } else if (command.type === 'attack') {
                      socket.emit('attack', command.data);
                  }
              }
          }
      }
      
      function handleKeyUp(e) {
          if (!socket || !playerId) return;
          
          let buttonId = null;
          let shouldStopMove = false;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
              }
          }
          
          // Remove active class from the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button) {
                  button.classList.remove('active');
              }
              
              // Stop movement if needed
              if (shouldStopMove && !gameEnding) {
                  socket.emit('stopMove');
              }
          }
      }
      
      function setupRestartButton() {
          const restartBtn = document.getElementById('restartBtn');
          
          // Add event handler for restart button
          restartBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              
              if (socket && playerId) {
                  // Play button sound
                  playSound('button');
                  
                  // Send player ready status to server
                  socket.emit('playerReady', playerId);
                  
                  // Update button state
                  this.textContent = 'Waiting for other player...';
                  this.disabled = true;
                  
                  debug("Sent playerReady: " + playerId);
              }
          });
      }
      
      function gameLoop(timestamp) {
          // Calculate delta time for smooth animations
          const deltaTime = timestamp - lastTime;
          lastTime = timestamp;
          
          // Update animation frame
          animationFrame += ANIMATION_SPEED * (deltaTime / 16.67); // Normalize to ~60fps
          
          // Update player animations
          updatePlayerAnimations(deltaTime);

          // Update background manager with player positions
          if (backgroundManager) {
              backgroundManager.update(deltaTime);
          }

          // Update weather system
          if (weatherSystem) {
              weatherSystem.update(deltaTime);
          }

          // Update hit detection (only if game is active and not ending)
          if (gameStarted && !gameEnding) {
              checkHits();
          }
          
          // Clear canvas
          ctx.clearRect(0, 0, gameWidth, gameHeight);
          
          // Draw game elements
          if (backgroundManager) {
              backgroundManager.draw(players);
          } else {
              // Fallback to original background if manager not ready
              drawBackground();
          }

          // Always draw players, even if game is not started
          if (players.player1 && players.player2) {
              drawPlayers();
          }

          // Draw hit feedback and power bars if game is active or ending
          if (gameStarted || gameEnding) {
              drawHitFeedback();
              drawPowerBars();
              // drawHitboxes(); // Uncomment for debugging
          }

          // Draw weather effects on top of everything
          if (weatherSystem) {
              weatherSystem.draw();
          }
          
          // Continue the game loop
          requestAnimationFrame(gameLoop);
      }
      
      // Update player animations
      function updatePlayerAnimations(deltaTime) {
          // Update player 1 animations
          updatePlayerAnimation('player1', deltaTime);
          
          // Update player 2 animations
          updatePlayerAnimation('player2', deltaTime);
      }
      
      // Update individual player animation
      function updatePlayerAnimation(playerId, deltaTime) {
          const anim = playerAnimations[playerId];
          
          // Update breathing animation for idle
          if (anim.state === IDLE) {
              anim.breatheOffset += anim.breatheDirection * 0.02 * (deltaTime / 16.67);
              
              // Reverse direction at limits
              if (anim.breatheOffset > 1) {
                  anim.breatheOffset = 1;
                  anim.breatheDirection = -1;
              } else if (anim.breatheOffset < -1) {
                  anim.breatheOffset = -1;
                  anim.breatheDirection = 1;
              }
          }
          
          // Update walking animation
          if (anim.state === WALKING) {
              anim.walkCycle += 0.1 * (deltaTime / 16.67);
              if (anim.walkCycle > Math.PI * 2) {
                  anim.walkCycle -= Math.PI * 2;
              }
          }
          
          // Update hurt animation
          if (anim.state === HURT) {
              anim.hurtAngle += anim.hurtDirection * 0.2 * (deltaTime / 16.67);
              
              // Limit the hurt angle
              if (Math.abs(anim.hurtAngle) > Math.PI / 6) {
                  anim.hurtDirection *= -0.7; // Bounce back with damping
              }
          }
          
          // Update victory animation
          if (anim.state === VICTORY) {
              anim.victoryJump += 0.1 * (deltaTime / 16.67);
              if (anim.victoryJump > Math.PI * 2) {
                  anim.victoryJump -= Math.PI * 2;
              }
          }
          
          // Update defeat animation
          if (anim.state === DEFEAT) {
              if (anim.defeatFall < 1) {
                  anim.defeatFall += 0.02 * (deltaTime / 16.67);
                  if (anim.defeatFall > 1) anim.defeatFall = 1;
              }
          }
      }

      // Calculate hitboxes for a player
      function calculateHitboxes(playerId) {
          if (!players[playerId]) return null;
          
          const player = players[playerId];
          const anim = playerAnimations[playerId];
          const facingLeft = playerId === 'player2'; // Player 2 faces left
          
          // Calculate scale factor based on screen width
          const scaleFactor = Math.min(1, gameWidth / 800);
          const floorY = gameHeight - 50;
          
          // Adjust player positions for smaller screens
          const screenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, player.x * scaleFactor));
          const screenY = floorY - PLAYER_HEIGHT;
          
          // Apply animation offsets
          let yOffset = 0;
          if (anim.state === VICTORY) {
              yOffset = -Math.abs(Math.sin(anim.victoryJump) * 20);
          } else if (anim.state === DEFEAT) {
              yOffset = anim.defeatFall * 20;
          }
          
          // Calculate center point
          const centerX = screenX + PLAYER_WIDTH / 2;
          const headY = screenY + 10 + anim.breatheOffset + yOffset;
          
          // Calculate attack point (where hits land)
          let attackX = centerX + (facingLeft ? -ARM_HITBOX_WIDTH : ARM_HITBOX_WIDTH);
          let attackY = screenY + 25 + yOffset;
          let attackRange = 10; // Default attack range

          if (anim.state === HITTING) {
              attackRange = 10;
          } else if (anim.state === KICKING) {
              // Extend kick range and adjust position
              attackX = centerX + (facingLeft ? -LEG_HITBOX_WIDTH - 10 : LEG_HITBOX_WIDTH + 10);
              attackY = screenY + 60 + yOffset;
              attackRange = 15; // Larger range for kicks
          }
          
          return {
              id: playerId,
              head: {
                  x: centerX,
                  y: headY,
                  radius: HEAD_HITBOX_RADIUS
              },
              body: {
                  x: centerX,
                  y: screenY + 35 + yOffset,
                  width: BODY_HITBOX_WIDTH,
                  height: BODY_HITBOX_HEIGHT
              },
              attackPoint: {
                  x: attackX,
                  y: attackY,
                  active: anim.state === HITTING || anim.state === KICKING,
                  type: anim.state === HITTING ? 'hit' : 'kick',
                  range: attackRange
              }
          };
      }

      // Check for hits between players
      function checkHits() {
          if (!gameStarted || !players.player1 || !players.player2 || gameEnding) return;
          
          // Don't check hits too frequently
          const now = performance.now();
          if (now - lastHitTime < HIT_COOLDOWN) return;
          
          // Calculate hitboxes
          const p1Hitbox = calculateHitboxes('player1');
          const p2Hitbox = calculateHitboxes('player2');
          
          if (!p1Hitbox || !p2Hitbox) return;
          
          // Check player 1 attacking player 2
          if (p1Hitbox.attackPoint.active && players.player1.state !== HURT) {
              const hit = detectHit(p1Hitbox.attackPoint, p2Hitbox);
              if (hit) {
                  applyHit('player1', 'player2', p1Hitbox.attackPoint, hit);
              }
          }
          
          // Check player 2 attacking player 1
          if (p2Hitbox.attackPoint.active && players.player2.state !== HURT) {
              const hit = detectHit(p2Hitbox.attackPoint, p1Hitbox);
              if (hit) {
                  applyHit('player2', 'player1', p2Hitbox.attackPoint, hit);
              }
          }
      }

      // Detect if an attack point hits a hitbox
      function detectHit(attackPoint, targetHitbox) {
          // Get attack range (or default to 10)
          const range = attackPoint.range || 10;
          
          // Check head hit (circular collision)
          const dx = attackPoint.x - targetHitbox.head.x;
          const dy = attackPoint.y - targetHitbox.head.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < targetHitbox.head.radius + range) {
              return { zone: 'head', point: { x: targetHitbox.head.x, y: targetHitbox.head.y } };
          }
          
          // Check body hit (rectangular collision with expanded range)
          const bodyLeft = targetHitbox.body.x - targetHitbox.body.width / 2 - range;
          const bodyRight = targetHitbox.body.x + targetHitbox.body.width / 2 + range;
          const bodyTop = targetHitbox.body.y - targetHitbox.body.height / 2 - range;
          const bodyBottom = targetHitbox.body.y + targetHitbox.body.height / 2 + range;
          
          if (attackPoint.x >= bodyLeft && attackPoint.x <= bodyRight &&
              attackPoint.y >= bodyTop && attackPoint.y <= bodyBottom) {
              return { zone: 'body', point: { x: attackPoint.x, y: attackPoint.y } };
          }
          
          return null;
      }

      // Apply hit effects
      function applyHit(attackerId, targetId, attackPoint, hit) {
          // Don't register hits if the game is over
          if (gameEnding || document.getElementById('winnerMessage').style.display === 'block') return;
          
          lastHitTime = performance.now();
          
          // Calculate damage based on attack type and hit zone
          let damage = attackPoint.type === 'hit' ? HIT_DAMAGE : KICK_DAMAGE;
          
          // Critical hit for headshots
          if (hit.zone === 'head') {
              damage *= CRITICAL_HIT_MULTIPLIER;
          }
          
          // Send attack to server
          if (socket) {
              socket.emit('registerHit', {
                  attackerId: attackerId,
                  targetId: targetId,
                  damage: damage,
                  hitZone: hit.zone
              });
          }
          
          // Show hit feedback
          hitFeedback = {
              active: true,
              x: hit.point.x,
              y: hit.point.y,
              type: hit.zone === 'head' ? 'critical' : 'normal',
              time: performance.now()
          };
      }

      // Draw hit feedback
      function drawHitFeedback() {
          if (!hitFeedback.active) return;
          
          const now = performance.now();
          const elapsed = now - hitFeedback.time;
          
          if (elapsed > HIT_FEEDBACK_DURATION) {
              hitFeedback.active = false;
              return;
          }
          
          // Calculate animation progress (0 to 1)
          const progress = elapsed / HIT_FEEDBACK_DURATION;
          const size = 20 + progress * 30;
          const opacity = 1 - progress;
          
          ctx.save();
          
          // Draw hit effect
          if (hitFeedback.type === 'critical') {
              // Critical hit effect (red burst)
              ctx.fillStyle = `rgba(255, 50, 50, ${opacity})`;
              ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
          } else {
              // Normal hit effect (white burst)
              ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
              ctx.strokeStyle = `rgba(200, 200, 200, ${opacity})`;
          }
          
          // Draw burst
          ctx.beginPath();
          ctx.arc(hitFeedback.x, hitFeedback.y, size / 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw impact lines
          ctx.lineWidth = 3;
          for (let i = 0; i < 8; i++) {
              const angle = Math.PI * 2 * i / 8;
              const innerRadius = size / 2;
              const outerRadius = size;
              
              ctx.beginPath();
              ctx.moveTo(
                  hitFeedback.x + Math.cos(angle) * innerRadius,
                  hitFeedback.y + Math.sin(angle) * innerRadius
              );
              ctx.lineTo(
                  hitFeedback.x + Math.cos(angle) * outerRadius,
                  hitFeedback.y + Math.sin(angle) * outerRadius
              );
              ctx.stroke();
          }
          
          ctx.restore();
      }

      // Draw hitboxes for debugging
      function drawHitboxes() {
          if (!players.player1 || !players.player2) return;
          
          const p1Hitbox = calculateHitboxes('player1');
          const p2Hitbox = calculateHitboxes('player2');
          
          if (!p1Hitbox || !p2Hitbox) return;
          
          ctx.save();
          
          // Draw player 1 hitboxes
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.lineWidth = 2;
          
          // Head
          ctx.beginPath();
          ctx.arc(p1Hitbox.head.x, p1Hitbox.head.y, p1Hitbox.head.radius, 0, Math.PI * 2);
          ctx.stroke();
          
          // Body
          ctx.strokeRect(
              p1Hitbox.body.x - p1Hitbox.body.width / 2,
              p1Hitbox.body.y - p1Hitbox.body.height / 2,
              p1Hitbox.body.width,
              p1Hitbox.body.height
          );
          
          // Attack point
          if (p1Hitbox.attackPoint.active) {
              ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
              ctx.beginPath();
              ctx.arc(p1Hitbox.attackPoint.x, p1Hitbox.attackPoint.y, 5, 0, Math.PI * 2);
              ctx.fill();
              
              // Draw attack range
              ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
              ctx.beginPath();
              ctx.arc(p1Hitbox.attackPoint.x, p1Hitbox.attackPoint.y, p1Hitbox.attackPoint.range, 0, Math.PI * 2);
              ctx.stroke();
          }
          
          // Draw player 2 hitboxes
          ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
          
          // Head
          ctx.beginPath();
          ctx.arc(p2Hitbox.head.x, p2Hitbox.head.y, p2Hitbox.head.radius, 0, Math.PI * 2);
          ctx.stroke();
          
          // Body
          ctx.strokeRect(
              p2Hitbox.body.x - p2Hitbox.body.width / 2,
              p2Hitbox.body.y - p2Hitbox.body.height / 2,
              p2Hitbox.body.width,
              p2Hitbox.body.height
          );
          
          // Attack point
          if (p2Hitbox.attackPoint.active) {
              ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';
              ctx.beginPath();
              ctx.arc(p2Hitbox.attackPoint.x, p2Hitbox.attackPoint.y, 5, 0, Math.PI * 2);
              ctx.fill();
              
              // Draw attack range
              ctx.strokeStyle = 'rgba(0, 0, 255,
