<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stickman Fighter with Blocking</title>
  <!-- Load Socket.io from CDN -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          touch-action: none;
          background-color: #222;
          font-family: Arial, sans-serif;
      }
      #gameContainer {
          position: relative;
          width: 100vw;
          height: 100vh;
          overflow: hidden;
      }
      #gameCanvas {
          background-color: #333;
          position: absolute;
          top: 0;
          left: 0;
      }
      .controls {
          position: fixed;
          bottom: 30px;
          width: 100%;
          padding: 0 10px;
          box-sizing: border-box;
          z-index: 10;
          display: flex;
          justify-content: center;
      }
      .player-controls {
          display: flex;
          gap: 12px;
          margin-bottom: 15px;
      }
      .control-btn {
          width: 65px;
          height: 65px;
          border-radius: 50%;
          border: none;
          background-color: rgba(255, 255, 255, 0.3);
          color: white;
          font-weight: bold;
          font-size: 18px;
          touch-action: manipulation;
          user-select: none;
          -webkit-user-select: none;
          transition: all 0.1s ease;
          position: relative;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      /* Button press effect */
      .control-btn.active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
      }
      @media (max-width: 480px) {
          .control-btn {
              width: 55px;
              height: 55px;
              font-size: 16px;
          }
          .player-controls {
              gap: 10px;
          }
      }
      @media (max-width: 360px) {
          .control-btn {
              width: 45px;
              height: 45px;
              font-size: 14px;
          }
          .player-controls {
              gap: 8px;
          }
      }
      .hit-btn {
          background-color: rgba(255, 50, 50, 0.7);
      }
      .hit-btn.active {
          background-color: rgba(255, 50, 50, 0.9);
      }
      .kick-btn {
          background-color: rgba(50, 50, 255, 0.7);
      }
      .kick-btn.active {
          background-color: rgba(50, 50, 255, 0.9);
      }
      .move-btn {
          background-color: rgba(50, 200, 50, 0.7);
      }
      .move-btn.active {
          background-color: rgba(50, 200, 50, 0.9);
      }
      /* New block button style */
      .block-btn {
          background-color: rgba(255, 200, 50, 0.7);
      }
      .block-btn.active {
          background-color: rgba(255, 200, 50, 0.9);
      }
      /* NEW: Special move button styles */
      .special-btn {
          background-color: rgba(180, 50, 200, 0.7);
      }
      .special-btn.active {
          background-color: rgba(180, 50, 200, 0.9);
      }
      .grab-btn {
          background-color: rgba(255, 120, 0, 0.7);
      }
      .grab-btn.active {
          background-color: rgba(255, 120, 0, 0.9);
      }
      /* Button ripple effect */
      .control-btn::after {
          content: '';
          position: absolute;
          top: 50%;
          left: 50%;
          width: 5px;
          height: 5px;
          background: rgba(255, 255, 255, 0.5);
          opacity: 0;
          border-radius: 100%;
          transform: scale(1, 1) translate(-50%, -50%);
          transform-origin: 50% 50%;
      }
      .control-btn.active::after {
          animation: ripple 0.4s ease-out;
      }
      @keyframes ripple {
          0% {
              transform: scale(0, 0) translate(-50%, -50%);
              opacity: 0.5;
          }
          100% {
              transform: scale(20, 20) translate(-50%, -50%);
              opacity: 0;
          }
      }
      #winnerMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 30px;
          border-radius: 10px;
          font-size: 24px;
          display: none;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #restartBtn {
          margin-top: 20px;
          padding: 15px 30px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 18px;
          touch-action: manipulation;
          transition: all 0.1s ease;
          box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      }
      #restartBtn:active {
          transform: scale(0.95) translateY(4px);
          box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
          background-color: #3e8e41;
      }
      #restartBtn:disabled {
          background-color: #888;
          cursor: default;
          transform: none;
          box-shadow: none;
      }
      #waitingMessage {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 20px;
          border-radius: 10px;
          font-size: 20px;
          text-align: center;
          z-index: 20;
          width: 80%;
          max-width: 300px;
      }
      #playerIndicator {
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 16px;
          z-index: 30;
          text-align: center;
      }
      #debugInfo {
          position: fixed;
          top: 40px;
          left: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          font-size: 12px;
          z-index: 30;
          display: none;
      }
      /* Add a game area container to help with positioning */
      #gameArea {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: calc(100% - 130px); /* Reserve space for controls */
          overflow: hidden;
      }
      /* Player ready status styles */
      .player-status {
          margin-top: 10px;
          display: flex;
          justify-content: space-between;
          width: 100%;
      }
      .status-indicator {
          padding: 5px 10px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
      }
      .status-waiting {
          color: #ff5555;
      }
      .status-ready {
          color: #55ff55;
      }
      /* Sound control styles */
      #soundControl {
          position: fixed;
          top: 10px;
          right: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 5px;
          border-radius: 5px;
          z-index: 30;
          cursor: pointer;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
      }
      /* Block indicator styles */
      .block-indicator {
          position: absolute;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: rgba(255, 200, 50, 0.5);
          border: 2px solid rgba(255, 200, 50, 0.8);
          display: none;
          z-index: 5;
          animation: pulse 1s infinite;
      }
      @keyframes pulse {
          0% { transform: scale(1); opacity: 0.7; }
          50% { transform: scale(1.1); opacity: 0.9; }
          100% { transform: scale(1); opacity: 0.7; }
      }
      /* Block cooldown indicator */
      .block-cooldown {
          position: absolute;
          bottom: -10px;
          left: 50%;
          transform: translateX(-50%);
          width: 100%;
          height: 5px;
          background-color: rgba(255, 255, 255, 0.3);
          border-radius: 2px;
          overflow: hidden;
      }
      .block-cooldown-fill {
          height: 100%;
          width: 100%;
          background-color: rgba(255, 200, 50, 0.8);
          transform-origin: left;
      }
      /* NEW: Invulnerability effect */
      .invulnerable-effect {
          position: absolute;
          width: 60px;
          height: 100px;
          border-radius: 30px;
          background-color: rgba(74, 144, 226, 0.3);
          border: 2px dashed rgba(74, 144, 226, 0.8);
          display: none;
          z-index: 4;
          animation: invulnerable-flash 0.5s infinite alternate;
      }
      @keyframes invulnerable-flash {
          0% { opacity: 0.3; }
          100% { opacity: 0.7; }
      }
      /* NEW: Combo counter */
      .combo-counter {
          position: absolute;
          color: #ff4444;
          font-weight: bold;
          font-size: 24px;
          text-shadow: 2px 2px 3px black;
          z-index: 100;
          display: none;
          pointer-events: none;
          text-align: center;
          width: 100px;
          transform: translateX(-50%);
      }
  </style>
</head>
<body>
  <div id="gameContainer">
      <div id="playerIndicator"></div>
      <div id="debugInfo"></div>
      <div id="soundControl">üîä</div>
      
      <div id="gameArea">
          <canvas id="gameCanvas"></canvas>
      </div>
      
      <div class="controls" id="controlsContainer">
          <!-- Control buttons will be added here dynamically -->
      </div>
      
      <div id="winnerMessage">
          <div id="winnerText"></div>
          <div class="player-status">
              <div id="player1Status" class="status-indicator status-waiting">Player 1: Waiting</div>
              <div id="player2Status" class="status-indicator status-waiting">Player 2: Waiting</div>
          </div>
          <button id="restartBtn">Play Again</button>
      </div>
      
      <div id="waitingMessage">
          Connecting to server...
      </div>
  </div>

  <!-- NEW: Add combo counter elements -->
  <div id="player1-combo" class="combo-counter"></div>
  <div id="player2-combo" class="combo-counter"></div>

  <!-- NEW: Add invulnerability effect elements -->
  <div id="player1-invulnerable" class="invulnerable-effect"></div>
  <div id="player2-invulnerable" class="invulnerable-effect"></div>

  <script>
      // Game variables
      let canvas, ctx;
      let gameWidth, gameHeight;
      let socket;
      let playerId;
      let players = {};
      let gameStarted = false;
      let readyPlayers = []; // Track which players are ready
      let gameState = {};
      let gameEnding = false; // Flag to track if the game is in the ending sequence
      let gameEndTime = 0; // Time when the game ended
      let winnerAnnounced = false; // Flag to track if the winner has been announced

      // Hit detection variables
      let lastHitTime = 0;
      let hitFeedback = {
          active: false,
          x: 0,
          y: 0,
          type: '',
          time: 0
      };

      // Block variables
      let blockIndicators = {};
      let blockCooldowns = {
          player1: 0,
          player2: 0
      };

      // NEW: Invulnerability variables
      let invulnerabilityEffects = {};
      let comboCounts = {
          player1: 0,
          player2: 0
      };
      let lastHitTimes = {
          player1: 0,
          player2: 0
      };

      // NEW: Special move variables
      let specialMoveCooldowns = {
          player1: 0,
          player2: 0
      };
      let buttonCombos = {
          player1: {
              sequence: [],
              lastPressTime: 0
          },
          player2: {
              sequence: [],
              lastPressTime: 0
          }
      };

      // NEW: Grab/throw variables
      let grabStates = {
          player1: {
              isGrabbing: false,
              grabTarget: null,
              grabStartTime: 0,
              isBeingGrabbed: false,
              escapeAttempts: 0
          },
          player2: {
              isGrabbing: false,
              grabTarget: null,
              grabStartTime: 0,
              isBeingGrabbed: false,
              escapeAttempts: 0
          }
      };

      const GLITCH_SERVER_URL = "https://stickmanfightingnew.glitch.me";
      
      // Sound variables
      let soundEnabled = true;
      let sounds = {};
      let soundsLoaded = false;
      
      // Game constants
      const PLAYER_WIDTH = 30;
      const PLAYER_HEIGHT = 80;
      const PLAYER_SPEED = 5;
      const MAX_POWER = 100;
      const HIT_DAMAGE = 10;
      const KICK_DAMAGE = 15;
      const HIT_RANGE = 40;
      const KICK_RANGE = 50;
      const GAME_END_DELAY = 1500; // Delay before showing winner message (ms)

      // Block constants
      const BLOCK_DURATION = 1000; // How long a block lasts (ms)
      const BLOCK_COOLDOWN = 2000; // Cooldown before can block again (ms)
      const BLOCK_DAMAGE_REDUCTION = 0.75; // Reduce damage by 75% when blocking

      // NEW: Invulnerability constants
      const INVULNERABILITY_DURATION = 1500; // 1.5 seconds of invulnerability after being hit
      const COMBO_LIMIT = 3; // Maximum number of consecutive hits before forced invulnerability
      const COMBO_RESET_TIME = 3000; // Time after which combo counter resets

      // NEW: Special move constants
      const SPECIAL_MOVE_DAMAGE = 25;
      const SPECIAL_MOVE_COOLDOWN = 3000; // 3 seconds cooldown
      const BUTTON_COMBO_TIMEOUT = 500; // Time window for button combinations (ms)

      // NEW: Grab/throw constants
      const GRAB_RANGE = 30; // Distance for grab attempts
      const GRAB_DURATION = 1000; // How long a grab lasts before throw (ms)
      const THROW_DAMAGE = 20; // Damage from being thrown
      const THROW_DISTANCE = 150; // How far the opponent is thrown
      const THROW_STUN_DURATION = 1000; // How long the thrown player is stunned (ms)
      const GRAB_ESCAPE_DIFFICULTY = 5; // Higher = harder to escape (1-10)

      // Hit detection constants
      const HEAD_HITBOX_RADIUS = 10;
      const BODY_HITBOX_WIDTH = 20;
      const BODY_HITBOX_HEIGHT = 30;
      const ARM_HITBOX_WIDTH = 30;
      const LEG_HITBOX_WIDTH = 30;
      const CRITICAL_HIT_MULTIPLIER = 1.5;
      const HIT_COOLDOWN = 300; // ms
      const HIT_FEEDBACK_DURATION = 200; // ms
      
      // Animation states
      const IDLE = 'idle';
      const HITTING = 'hitting';
      const KICKING = 'kicking';
      const BLOCKING = 'blocking'; // New blocking state
      const HURT = 'hurt';
      const WALKING = 'walking';
      const VICTORY = 'victory';
      const DEFEAT = 'defeat';
      
      // NEW: Special move states
      const SPECIAL_ATTACK = 'special';
      const GRAB_ATTEMPT = 'grab';
      const GRABBED = 'grabbed';
      const THROWING = 'throwing';
      const THROWN = 'thrown';
      
      // Animation variables
      let animationFrame = 0;
      const ANIMATION_SPEED = 0.1; // Lower is slower
      let lastTime = 0;
      
      // Animation data for each player
      const playerAnimations = {
          player1: {
              state: IDLE,
              frame: 0,
              breatheOffset: 0,
              breatheDirection: 1,
              walkCycle: 0,
              hurtAngle: 0,
              hurtDirection: 1,
              victoryJump: 0,
              defeatFall: 0,
              blockStart: 0, // When block started
              specialAttackFrame: 0,
              grabFrame: 0,
              throwFrame: 0,
              thrownFrame: 0,
          },
          player2: {
              state: IDLE,
              frame: 0,
              breatheOffset: 0,
              breatheDirection: 1,
              walkCycle: 0,
              hurtAngle: 0,
              hurtDirection: -1,
              victoryJump: 0,
              defeatFall: 0,
              blockStart: 0, // When block started
              specialAttackFrame: 0,
              grabFrame: 0,
              throwFrame: 0,
              thrownFrame: 0,
          }
      };
      
      // Debug function
      function debug(message) {
          const debugElement = document.getElementById('debugInfo');
          debugElement.style.display = 'block';
          debugElement.textContent = message;
          console.log(message);
      }
      
      // Initialize the game
      window.onload = function() {
          canvas = document.getElementById('gameCanvas');
          ctx = canvas.getContext('2d');
          
          // Set canvas size
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          
          // Load sounds
          loadSounds();
          
          // Set up sound control
          setupSoundControl();
          
          // Connect to server automatically
          connectToServer();
          
          // Set up restart button with multiple event types
          setupRestartButton();
          
          // Create block indicators
          createBlockIndicators();
          
          // NEW: Create invulnerability effects
          createInvulnerabilityEffects();
          
          // Start game loop
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
      };
      
      // NEW: Create invulnerability effects for both players
      function createInvulnerabilityEffects() {
          // Get the elements
          const p1Effect = document.getElementById('player1-invulnerable');
          const p2Effect = document.getElementById('player2-invulnerable');
          
          // Store references
          invulnerabilityEffects = {
              player1: p1Effect,
              player2: p2Effect
          };
      }
      
      // Create block indicators for both players
      function createBlockIndicators() {
          // Create player 1 block indicator
          const p1Indicator = document.createElement('div');
          p1Indicator.className = 'block-indicator';
          p1Indicator.id = 'player1BlockIndicator';
          document.getElementById('gameArea').appendChild(p1Indicator);
          
          // Add cooldown bar for player 1
          const p1Cooldown = document.createElement('div');
          p1Cooldown.className = 'block-cooldown';
          p1Indicator.appendChild(p1Cooldown);
          
          const p1CooldownFill = document.createElement('div');
          p1CooldownFill.className = 'block-cooldown-fill';
          p1CooldownFill.id = 'player1BlockCooldown';
          p1Cooldown.appendChild(p1CooldownFill);
          
          // Create player 2 block indicator
          const p2Indicator = document.createElement('div');
          p2Indicator.className = 'block-indicator';
          p2Indicator.id = 'player2BlockIndicator';
          document.getElementById('gameArea').appendChild(p2Indicator);
          
          // Add cooldown bar for player 2
          const p2Cooldown = document.createElement('div');
          p2Cooldown.className = 'block-cooldown';
          p2Indicator.appendChild(p2Cooldown);
          
          const p2CooldownFill = document.createElement('div');
          p2CooldownFill.className = 'block-cooldown-fill';
          p2CooldownFill.id = 'player2BlockCooldown';
          p2Cooldown.appendChild(p2CooldownFill);
          
          // Store references
          blockIndicators = {
              player1: p1Indicator,
              player2: p2Indicator
          };
      }
      
      // Load all game sounds
      function loadSounds() {
          const soundFiles = {
              hit: '/Stickman-Fighter-v2/assets/punch.mp3',
              kick: '/Stickman-Fighter-v2/assets/kick.mp3',
              hurt: '/Stickman-Fighter-v2/assets/hurt.mp3',
              victory: '/Stickman-Fighter-v2/assets/victory.mp3',
              gameStart: '/Stickman-Fighter-v2/assets/game-start.mp3',
              button: '/Stickman-Fighter-v2/assets/button-press.mp3',
              block: '/Stickman-Fighter-v2/assets/block.mp3', // New block sound
              blockHit: '/Stickman-Fighter-v2/assets/block-hit.mp3', // New block hit sound
              invulnerable: '/Stickman-Fighter-v2/assets/block.mp3', // NEW: Reuse block sound for invulnerability
              special: '/Stickman-Fighter-v2/assets/special.mp3', // Special move sound
              grab: '/Stickman-Fighter-v2/assets/block.mp3', // Reuse block sound for grab
              throw: '/Stickman-Fighter-v2/assets/kick.mp3', // Reuse kick sound for throw
          };
          
          let loadedCount = 0;
          const totalSounds = Object.keys(soundFiles).length;
          
          // Create audio objects for each sound
          for (const [name, url] of Object.entries(soundFiles)) {
              sounds[name] = new Audio();
              sounds[name].src = url;
              
              // Handle loading
              sounds[name].addEventListener('canplaythrough', () => {
                  loadedCount++;
                  if (loadedCount === totalSounds) {
                      soundsLoaded = true;
                      console.log('All sounds loaded');
                  }
              });
              
              // Handle errors
              sounds[name].addEventListener('error', (e) => {
                  console.error(`Error loading sound ${name}:`, e);
              });
              
              // Preload the sound
              sounds[name].load();
          }
      }
      
      // Play a sound with error handling
      function playSound(name) {
          if (!soundEnabled || !soundsLoaded) return;
          
          try {
              // Create a clone to allow overlapping sounds
              const sound = sounds[name].cloneNode();
              sound.volume = 0.5; // Set volume to 50%
              
              // Play the sound with a promise and catch any errors
              const playPromise = sound.play();
              
              if (playPromise !== undefined) {
                  playPromise.catch(error => {
                      console.warn(`Sound play error (${name}):`, error);
                  });
              }
          } catch (error) {
              console.error(`Error playing sound ${name}:`, error);
          }
      }
      
      // Set up sound control button
      function setupSoundControl() {
          const soundControl = document.getElementById('soundControl');
          
          soundControl.addEventListener('click', function() {
              soundEnabled = !soundEnabled;
              this.textContent = soundEnabled ? 'üîä' : 'üîá';
              
              // Play a sound to confirm it's working
              if (soundEnabled) {
                  playSound('button');
              }
          });
      }
      
      function resizeCanvas() {
          // Get the gameArea dimensions
          const gameArea = document.getElementById('gameArea');
          gameWidth = gameArea.clientWidth;
          gameHeight = gameArea.clientHeight;
          
          canvas.width = gameWidth;
          canvas.height = gameHeight;
      }
      
      function connectToServer() {
          try {
              // Connect to the hardcoded Glitch server
              socket = io(GLITCH_SERVER_URL, {
                  transports: ['websocket', 'polling'],
                  reconnectionAttempts: 5
              });
              
              socket.on('connect', function() {
                  console.log('Connected to server');
                  document.getElementById('waitingMessage').textContent = 'Waiting for another player to join...';
              });
              
              socket.on('connect_error', function(error) {
                  console.error('Connection error:', error);
                  document.getElementById('waitingMessage').textContent = 'Connection error. Please try again.';
                  // Try to reconnect after 3 seconds
                  setTimeout(connectToServer, 3000);
              });
              
              socket.on('playerId', function(id) {
                  playerId = id;
                  console.log('Your player ID:', playerId);
                  
                  // Show player indicator
                  document.getElementById('playerIndicator').textContent = 
                      id === 'player1' ? 'You are Player 1 (Red)' : 'You are Player 2 (Blue)';
                  
                  // Set up controls for this player
                  setupPlayerControls();
              });
              
              socket.on('gameState', function(state) {
                  // Track previous player states to detect changes for sound effects
                  const prevPlayer1State = players.player1 ? players.player1.state : null;
                  const prevPlayer2State = players.player2 ? players.player2.state : null;
                  const prevPlayer1Power = players.player1 ? players.player1.power : MAX_POWER;
                  const prevPlayer2Power = players.player2 ? players.player2.power : MAX_POWER;
                  const wasGameStarted = gameStarted;
                  
                  // Store the previous winner
                  const prevWinner = gameState.winner;
                  
                  // Update game state
                  players = state.players;
                  gameStarted = state.gameStarted;
                  gameState = state;
                  
                  // Add isMoving property if it doesn't exist
                  if (players.player1 && players.player1.isMoving === undefined) {
                      players.player1.isMoving = false;
                  }
                  if (players.player2 && players.player2.isMoving === undefined) {
                      players.player2.isMoving = false;
                  }
                  
                  // Add blocking property if it doesn't exist
                  if (players.player1 && players.player1.blocking === undefined) {
                      players.player1.blocking = false;
                  }
                  if (players.player2 && players.player2.blocking === undefined) {
                      players.player2.blocking = false;
                  }
                  
                  // NEW: Add invulnerability properties if they don't exist
                  if (players.player1 && players.player1.isInvulnerable === undefined) {
                      players.player1.isInvulnerable = false;
                  }
                  if (players.player2 && players.player2.isInvulnerable === undefined) {
                      players.player2.isInvulnerable = false;
                  }

                  // NEW: Add special move properties if they don't exist
                  if (players.player1 && players.player1.specialMove === undefined) {
                      players.player1.specialMove = false;
                  }
                  if (players.player2 && players.player2.specialMove === undefined) {
                      players.player2.specialMove = false;
                  }

                  // NEW: Add grab/throw properties if they don't exist
                  if (players.player1 && players.player1.isGrabbing === undefined) {
                      players.player1.isGrabbing = false;
                      players.player1.grabTarget = null;
                  }
                  if (players.player2 && players.player2.isGrabbing === undefined) {
                      players.player2.isGrabbing = false;
                      players.player2.grabTarget = null;
                  }
                  
                  // Check if a player's health just reached zero
                  const player1Defeated = prevPlayer1Power > 0 && players.player1.power <= 0;
                  const player2Defeated = prevPlayer2Power > 0 && players.player2.power <= 0;

                  // If a player was just defeated, start the game ending sequence
                  if ((player1Defeated || player2Defeated) && !gameEnding) {
                      gameEnding = true;
                      gameEndTime = performance.now();
                      
                      // Set victory/defeat animations immediately
                      if (player1Defeated) {
                          playerAnimations.player1.state = DEFEAT;
                          playerAnimations.player2.state = VICTORY;
                          
                          // Immediately show winner message without delay
                          showWinner('player2');
                          winnerAnnounced = true;
                      } else if (player2Defeated) {
                          playerAnimations.player1.state = VICTORY;
                          playerAnimations.player2.state = DEFEAT;
                          
                          // Immediately show winner message without delay
                          showWinner('player1');
                          winnerAnnounced = true;
                      }
                      
                      // Play hurt sound for the defeated player
                      if (player1Defeated) {
                          playSound('hurt');
                      } else if (player2Defeated) {
                          playSound('hurt');
                      }
                      
                      console.log("Game ending sequence started");
                  }
                  
                  // Update animation states based on player states
                  if (players.player1 && !gameEnding) {
                      // Check if player is blocking
                      if (players.player1.blocking) {
                          playerAnimations.player1.state = BLOCKING;
                          playerAnimations.player1.blockStart = performance.now();
                          updateBlockIndicator('player1', true);
                      } else {
                          updateAnimationState('player1', players.player1.state, players.player1.isMoving);
                          updateBlockIndicator('player1', false);
                      }
                      
                      // NEW: Update invulnerability effect
                      updateInvulnerabilityEffect('player1', players.player1.isInvulnerable);
                  }
                  
                  if (players.player2 && !gameEnding) {
                      // Check if player is blocking
                      if (players.player2.blocking) {
                          playerAnimations.player2.state = BLOCKING;
                          playerAnimations.player2.blockStart = performance.now();
                          updateBlockIndicator('player2', true);
                      } else {
                          updateAnimationState('player2', players.player2.state, players.player2.isMoving);
                          updateBlockIndicator('player2', false);
                      }
                      
                      // NEW: Update invulnerability effect
                      updateInvulnerabilityEffect('player2', players.player2.isInvulnerable);
                  }
                  
                  // Play game start sound when game begins
                  if (gameStarted && !wasGameStarted) {
                      playSound('gameStart');
                  }
                  
                  // Play sounds based on state changes
                  if (players.player1 && prevPlayer1State !== players.player1.state && !gameEnding) {
                      if (players.player1.state === HITTING) playSound('hit');
                      if (players.player1.state === KICKING) playSound('kick');
                      if (players.player1.state === HURT) playSound('hurt');
                      if (players.player1.blocking) playSound('block');
                  }
                  
                  if (players.player2 && prevPlayer2State !== players.player2.state && !gameEnding) {
                      if (players.player2.state === HITTING) playSound('hit');
                      if (players.player2.state === KICKING) playSound('kick');
                      if (players.player2.state === HURT) playSound('hurt');
                      if (players.player2.blocking) playSound('block');
                  }
                  
                  // Show/hide waiting message
                  document.getElementById('waitingMessage').style.display = 
                      gameStarted ? 'none' : 'block';
                  
                  // Check for winner
                  if (state.winner && !prevWinner) {
                      // Winner was just determined
                      console.log(`Winner determined: ${state.winner}`);
                      
                      // Start the game ending sequence if it hasn't already started
                      if (!gameEnding) {
                          gameEnding = true;
                          gameEndTime = performance.now();
                          
                          // Set victory/defeat animations immediately
                          if (state.winner === 'player1') {
                              playerAnimations.player1.state = VICTORY;
                              playerAnimations.player2.state = DEFEAT;
                          } else {
                              playerAnimations.player1.state = DEFEAT;
                              playerAnimations.player2.state = VICTORY;
                          }
                          
                          // Play victory sound
                          playSound('victory');
                      }
                  } else if (state.winner === null && prevWinner) {
                      // Game has been reset
                      resetGameState();
                  }
              });
              
              // Listen for player ready status updates
              socket.on('playerReady', function(players) {
                  readyPlayers = players;
                  updateReadyStatus();
                  
                  debug("Ready players: " + JSON.stringify(readyPlayers));
                  
                  // If this player is ready, update button state
                  if (readyPlayers.includes(playerId)) {
                      const restartBtn = document.getElementById('restartBtn');
                      restartBtn.textContent = 'Waiting for other player...';
                      restartBtn.disabled = true;
                  }
                  
                  // Play button sound when a player gets ready
                  playSound('button');
                  
                  // Check if both players are ready
                  if (readyPlayers.includes('player1') && readyPlayers.includes('player2')) {
                      debug("Both players ready, restarting game");
                      
                      // Hide winner message
                      document.getElementById('winnerMessage').style.display = 'none';
                      
                      // Reset game state locally
                      resetGameState();
                      
                      // Tell the server to restart the game
                      socket.emit('restartGame');
                  }
              });

              // Add a new socket event handler for game restart confirmation
              socket.on('gameRestarted', function() {
                  debug("Game has been restarted by server");
                  
                  // Hide winner message if it's still showing
                  document.getElementById('winnerMessage').style.display = 'none';
                  
                  // Reset game state
                  resetGameState();
                  
                  // Play game start sound
                  playSound('gameStart');
              });
              
              // NEW: Handle hit result event for invulnerability and combo tracking
              socket.on('hitResult', function(data) {
                  console.log('Hit result:', data);
                  
                  // Play appropriate sound
                  if (data.blocked) {
                      playSound('blockHit');
                  } else if (data.invulnerable) {
                      playSound('invulnerable');
                  }
                  
                  // Update combo counter if provided
                  if (data.comboCount && data.comboCount > 1) {
                      showComboCounter(data.attackerId, data.comboCount);
                  }
                  
                  // Update invulnerability status
                  if (data.invulnerable) {
                      // The target is now invulnerable
                      if (players[data.targetId]) {
                          players[data.targetId].isInvulnerable = true;
                          updateInvulnerabilityEffect(data.targetId, true);
                          
                          // Set a timeout to remove invulnerability after duration
                          setTimeout(() => {
                              if (players[data.targetId]) {
                                  players[data.targetId].isInvulnerable = false;
                                  updateInvulnerabilityEffect(data.targetId, false);
                              }
                          }, INVULNERABILITY_DURATION);
                      }
                  }
              });

              // Handle grab escape attempts
              socket.on('grabEscape', function(data) {
                  if (!gameStarted || !data.playerId) return;
                  
                  attemptGrabEscape(data.playerId);
              });

              // Handle special move events
              socket.on('specialMove', function(data) {
                  if (!gameStarted || !data.playerId) return;
                  
                  // Update player state for special move
                  if (players[data.playerId]) {
                      players[data.playerId].state = SPECIAL_ATTACK;
                      playerAnimations[data.playerId].state = SPECIAL_ATTACK;
                      playerAnimations[data.playerId].specialAttackFrame = 0;
                      
                      // Play special move sound
                      playSound('special');
                  }
              });

              // Handle throw events
              socket.on('throwPlayer', function(data) {
                  if (!gameStarted || !data.targetId) return;
                  
                  // Update player position after being thrown
                  if (players[data.targetId]) {
                      players[data.targetId].x += data.throwDistance;
                      
                      // Constrain to game boundaries
                      players[data.targetId].x = Math.max(0, Math.min(800, players[data.targetId].x));
                      
                      // Update animation state
                      playerAnimations[data.targetId].state = THROWN;
                      playerAnimations[data.attackerId].state = THROWING;
                      
                      // Play throw sound
                      playSound('throw');
                  }
              });
          } catch (error) {
              console.error('Error connecting to server:', error);
              document.getElementById('waitingMessage').textContent = 'Failed to connect to server. Please try again.';
              // Try to reconnect after 3 seconds
              setTimeout(connectToServer, 3000);
          }
      }
      
      // NEW: Show combo counter
      function showComboCounter(playerId, count) {
          const comboElement = document.getElementById(`${playerId}-combo`);
          if (!comboElement) return;
          
          // Get player position
          const playerElement = calculatePlayerScreenPosition(playerId);
          if (!playerElement) return;
          
          // Position combo counter above player
          comboElement.style.left = (playerElement.x + PLAYER_WIDTH / 2) + 'px';
          comboElement.style.top = (playerElement.y - 40) + 'px';
          
          // Show the combo count
          comboElement.textContent = `${count}x COMBO!`;
          comboElement.style.display = 'block';
          
          // Hide it after a short time
          setTimeout(() => {
              comboElement.style.display = 'none';
          }, 1000);
      }
      
      // NEW: Calculate player screen position
      function calculatePlayerScreenPosition(playerId) {
          if (!players[playerId]) return null;
          
          const player = players[playerId];
          const scaleFactor = Math.min(1, gameWidth / 800);
          const floorY = gameHeight - 50;
          
          // Adjust player positions for smaller screens
          const screenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, player.x * scaleFactor));
          const screenY = floorY - PLAYER_HEIGHT;
          
          return { x: screenX, y: screenY };
      }
      
      // NEW: Update invulnerability effect
      function updateInvulnerabilityEffect(playerId, isInvulnerable) {
          const effect = invulnerabilityEffects[playerId];
          if (!effect) return;
          
          if (isInvulnerable) {
              // Show effect
              effect.style.display = 'block';
              
              // Position effect around player
              const playerPos = calculatePlayerScreenPosition(playerId);
              if (playerPos) {
                  effect.style.left = (playerPos.x - 15) + 'px'; // Wider than player
                  effect.style.top = (playerPos.y - 10) + 'px'; // Taller than player
              }
          } else {
              // Hide effect
              effect.style.display = 'none';
          }
      }
      
      // Update block indicator position and visibility
      function updateBlockIndicator(playerId, isBlocking) {
          const indicator = blockIndicators[playerId];
          if (!indicator) return;
          
          if (isBlocking) {
              // Show indicator
              indicator.style.display = 'block';
              
              // Position indicator above player
              if (players[playerId]) {
                  const scaleFactor = Math.min(1, gameWidth / 800);
                  const screenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, players[playerId].x * scaleFactor));
                  const screenY = gameHeight - 50 - PLAYER_HEIGHT - 30; // Position above player
                  
                  indicator.style.left = (screenX + PLAYER_WIDTH / 2 - 20) + 'px'; // Center horizontally
                  indicator.style.top = screenY + 'px';
              }
          } else {
              // Hide indicator
              indicator.style.display = 'none';
          }
      }
      
      // Update block cooldown display
      function updateBlockCooldown(playerId, cooldownPercent) {
          const cooldownElement = document.getElementById(`${playerId}BlockCooldown`);
          if (cooldownElement) {
              cooldownElement.style.transform = `scaleX(${cooldownPercent})`;
          }
      }
      
      // Reset game state when a new game starts
      function resetGameState() {
          console.log("Resetting game state");
          
          // Hide winner message
          document.getElementById('winnerMessage').style.display = 'none';
          
          // Reset button state
          const restartBtn = document.getElementById('restartBtn');
          restartBtn.textContent = 'Play Again';
          restartBtn.disabled = false;
          
          // Reset player status indicators
          document.getElementById('player1Status').className = 'status-indicator status-waiting';
          document.getElementById('player1Status').textContent = 'Player 1: Waiting';
          document.getElementById('player2Status').className = 'status-indicator status-waiting';
          document.getElementById('player2Status').textContent = 'Player 2: Waiting';
          
          // Clear ready players array
          readyPlayers = [];
          
          // Reset animation states
          playerAnimations.player1.state = IDLE;
          playerAnimations.player2.state = IDLE;
          
          // Reset game ending flags
          gameEnding = false;
          gameEndTime = 0;
          winnerAnnounced = false;
          
          // Reset hit feedback
          hitFeedback.active = false;
          
          // Reset block cooldowns
          blockCooldowns.player1 = 0;
          blockCooldowns.player2 = 0;
          
          // Hide block indicators
          updateBlockIndicator('player1', false);
          updateBlockIndicator('player2', false);
          
          // NEW: Reset combo counters
          comboCounts.player1 = 0;
          comboCounts.player2 = 0;
          
          // NEW: Hide combo counters
          document.getElementById('player1-combo').style.display = 'none';
          document.getElementById('player2-combo').style.display = 'none';
          
          // NEW: Hide invulnerability effects
          updateInvulnerabilityEffect('player1', false);
          updateInvulnerabilityEffect('player2', false);

          // Reset special move cooldowns
          specialMoveCooldowns.player1 = 0;
          specialMoveCooldowns.player2 = 0;

          // Reset button combos
          buttonCombos.player1.sequence = [];
          buttonCombos.player2.sequence = [];

          // Reset grab states
          grabStates.player1 = {
              isGrabbing: false,
              grabTarget: null,
              grabStartTime: 0,
              isBeingGrabbed: false,
              escapeAttempts: 0
          };
          grabStates.player2 = {
              isGrabbing: false,
              grabTarget: null,
              grabStartTime: 0,
              isBeingGrabbed: false,
              escapeAttempts: 0
          };
      }
      
      // Update animation state based on player state
      function updateAnimationState(playerId, state, isMoving) {
          const anim = playerAnimations[playerId];
          
          // Don't update if we're in the game ending sequence
          if (gameEnding) return;
          
          // Only update if state changed
          if (anim.state !== state) {
              anim.frame = 0; // Reset animation frame on state change
              
              // Reset specific animation variables
              if (state === HURT) {
                  anim.hurtAngle = 0;
                  anim.hurtDirection = playerId === 'player1' ? 1 : -1;
              }
          }
          
          // Set the animation state
          anim.state = state;
          
          // Handle walking state
          if (isMoving && state === IDLE) {
              anim.state = WALKING;
          }
      }
      
      function updateReadyStatus() {
          // Update player 1 status
          const player1Status = document.getElementById('player1Status');
          if (readyPlayers.includes('player1')) {
              player1Status.className = 'status-indicator status-ready';
              player1Status.textContent = 'Player 1: Ready';
          } else {
              player1Status.className = 'status-indicator status-waiting';
              player1Status.textContent = 'Player 1: Waiting';
          }
          
          // Update player 2 status
          const player2Status = document.getElementById('player2Status');
          if (readyPlayers.includes('player2')) {
              player2Status.className = 'status-indicator status-ready';
              player2Status.textContent = 'Player 2: Ready';
          } else {
              player2Status.className = 'status-indicator status-waiting';
              player2Status.textContent = 'Player 2: Waiting';
          }
      }
      
      function setupPlayerControls() {
          const controlsContainer = document.getElementById('controlsContainer');
          
          // Clear any existing controls
          controlsContainer.innerHTML = '';
          
          // Create new control container
          const playerControls = document.createElement('div');
          playerControls.className = 'player-controls';
          playerControls.innerHTML = `
      <button class="control-btn move-btn" id="moveLeft">‚Üê</button>
      <button class="control-btn move-btn" id="moveRight">‚Üí</button>
      <button class="control-btn hit-btn" id="hitBtn">HIT</button>
      <button class="control-btn kick-btn" id="kickBtn">KICK</button>
      <button class="control-btn block-btn" id="blockBtn">BLOCK</button>
      <button class="control-btn grab-btn" id="grabBtn">GRAB</button>
  `;
          
          controlsContainer.appendChild(playerControls);
          
          // Setup touch event listeners
          setupControlEventListeners();
      }
      
      function setupControlEventListeners() {
          // Get all control buttons
          const moveLeftBtn = document.getElementById('moveLeft');
          const moveRightBtn = document.getElementById('moveRight');
          const hitBtn = document.getElementById('hitBtn');
          const kickBtn = document.getElementById('kickBtn');
          const blockBtn = document.getElementById('blockBtn');
          const grabBtn = document.getElementById('grabBtn');
          
          // Clear any existing event listeners (just in case)
          moveLeftBtn.replaceWith(moveLeftBtn.cloneNode(true));
          moveRightBtn.replaceWith(moveRightBtn.cloneNode(true));
          hitBtn.replaceWith(hitBtn.cloneNode(true));
          kickBtn.replaceWith(kickBtn.cloneNode(true));
          blockBtn.replaceWith(blockBtn.cloneNode(true));
          grabBtn.replaceWith(grabBtn.cloneNode(true));
          
          // Get the fresh elements
          const newMoveLeftBtn = document.getElementById('moveLeft');
          const newMoveRightBtn = document.getElementById('moveRight');
          const newHitBtn = document.getElementById('hitBtn');
          const newKickBtn = document.getElementById('kickBtn');
          const newBlockBtn = document.getElementById('blockBtn');
          const newGrabBtn = document.getElementById('grabBtn');
          
          // Add touch start event listeners
          newMoveLeftBtn.addEventListener('touchstart', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('touchstart', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('touchstart', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'hit'});
              trackButtonPress(playerId, 'hit');
          });
          
          newKickBtn.addEventListener('touchstart', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'kick'});
              trackButtonPress(playerId, 'kick');
          });
          
          newBlockBtn.addEventListener('touchstart', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding && canBlock(playerId)) {
                  socket.emit('block', {blocking: true});
                  startBlockCooldown(playerId);
              }
          });

          newGrabBtn.addEventListener('touchstart', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              e.preventDefault();
              this.classList.add('active');
              if (socket && !gameEnding) {
                  attemptGrab(playerId);
              }
          });
          
          // Add touch end event listeners
          newMoveLeftBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          newBlockBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('block', {blocking: false});
          });

          newGrabBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              this.classList.remove('active');
          });
          
          // For mouse users (testing)
          newMoveLeftBtn.addEventListener('mousedown', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'left'});
          });
          
          newMoveRightBtn.addEventListener('mousedown', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('move', {direction: 'right'});
          });
          
          newHitBtn.addEventListener('mousedown', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'hit'});
              trackButtonPress(playerId, 'hit');
          });
          
          newKickBtn.addEventListener('mousedown', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              this.classList.add('active');
              if (socket && !gameEnding) socket.emit('attack', {type: 'kick'});
              trackButtonPress(playerId, 'kick');
          });
          
          newBlockBtn.addEventListener('mousedown', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              this.classList.add('active');
              if (socket && !gameEnding && canBlock(playerId)) {
                  socket.emit('block', {blocking: true});
                  startBlockCooldown(playerId);
              }
          });

          newGrabBtn.addEventListener('mousedown', function(e) {
              if (grabStates[playerId].isBeingGrabbed) {
                  handleGrabEscapeButtonPress(playerId);
                  return;
              }
              this.classList.add('active');
              if (socket && !gameEnding) {
                  attemptGrab(playerId);
              }
          });
          
          newMoveLeftBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newMoveRightBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('stopMove');
          });
          
          newHitBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          newKickBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          newBlockBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
              if (socket && !gameEnding) socket.emit('block', {blocking: false});
          });

          newGrabBtn.addEventListener('mouseup', function(e) {
              this.classList.remove('active');
          });
          
          // Stop movement when mouse is released
          newMoveLeftBtn.addEventListener('mouseup', function(e) {
              if (playerId === 'player1') {
                  socket.emit('stopMove');
              }
          });
          
          newMoveRightBtn.addEventListener('mouseup', function(e) {
              if (playerId === 'player1') {
                  socket.emit('stopMove');
              }
          });
          
          newMoveLeftBtn.addEventListener('mouseup', function(e) {
              if (playerId === 'player2') {
                  socket.emit('stopMove');
              }
          });
          
          newMoveRightBtn.addEventListener('mouseup', function(e) {
              if (playerId === 'player2') {
                  socket.emit('stopMove');
              }
          });
          
          // Setup keyboard controls
          setupKeyboardControls();
      }
      
      // Check if player can block (not in cooldown)
      function canBlock(playerId) {
          return blockCooldowns[playerId] <= 0;
      }
      
      // Start block cooldown for a player
      function startBlockCooldown(playerId) {
          blockCooldowns[playerId] = BLOCK_COOLDOWN;
      }
      
      function setupKeyboardControls() {
          // Remove any existing event listeners
          window.removeEventListener('keydown', handleKeyDown);
          
          window.removeEventListener('keyup', handleKeyUp);
          
          // Add event listeners
          window.addEventListener('keydown', handleKeyDown);
          window.addEventListener('keyup', handleKeyUp);
      }
      
      function handleKeyDown(e) {
          if (!socket || !playerId || gameEnding) return;
          
          let buttonId = null;
          let command = null;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
              else if (e.key === 's') {
                  buttonId = 'blockBtn';
                  if (canBlock(playerId)) {
                      command = {type: 'block', data: {blocking: true}};
                      startBlockCooldown(playerId);
                  }
              }
              else if (e.key === 'f') {
                  buttonId = 'specialBtn';
                  if (specialMoveCooldowns[playerId] <= 0) {
                      executeSpecialMove(playerId);
                  }
              }
              else if (e.key === 'r') {
                  buttonId = 'grabBtn';
                  attemptGrab(playerId);
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  command = {type: 'move', data: {direction: 'left'}};
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  command = {type: 'move', data: {direction: 'right'}};
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
                  command = {type: 'attack', data: {type: 'hit'}};
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
                  command = {type: 'attack', data: {type: 'kick'}};
              }
              else if (e.key === 'ArrowDown') {
                  buttonId = 'blockBtn';
                  if (canBlock(playerId)) {
                      command = {type: 'block', data: {blocking: true}};
                      startBlockCooldown(playerId);
                  }
              }
              else if (e.key === '/') {
                  buttonId = 'specialBtn';
                  if (specialMoveCooldowns[playerId] <= 0) {
                      executeSpecialMove(playerId);
                  }
              }
              else if (e.key === 'm') {
                  buttonId = 'grabBtn';
                  attemptGrab(playerId);
              }
          }
          
          // Add active class to the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button && !button.classList.contains('active')) {
                  button.classList.add('active');
              }
              
              // Send command to server
              if (command) {
                  if (command.type === 'move') {
                      socket.emit('move', command.data);
                  } else if (command.type === 'attack') {
                      socket.emit('attack', command.data);
                  } else if (command.type === 'block') {
                      socket.emit('block', command.data);
                  }
              }
          }
      }
      
      function handleKeyUp(e) {
          if (!socket || !playerId) return;
          
          let buttonId = null;
          let shouldStopMove = false;
          let shouldStopBlock = false;
          
          // Player 1 controls
          if (playerId === 'player1') {
              if (e.key === 'a') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'd') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === 'q') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === 'e') {
                  buttonId = 'kickBtn';
              }
              else if (e.key === 's') {
                  buttonId = 'blockBtn';
                  shouldStopBlock = true;
              }
              else if (e.key === 'f') {
                  buttonId = 'specialBtn';
              }
              else if (e.key === 'r') {
                  buttonId = 'grabBtn';
              }
          }
          // Player 2 controls
          else if (playerId === 'player2') {
              if (e.key === 'ArrowLeft') {
                  buttonId = 'moveLeft';
                  shouldStopMove = true;
              }
              else if (e.key === 'ArrowRight') {
                  buttonId = 'moveRight';
                  shouldStopMove = true;
              }
              else if (e.key === ',') {
                  buttonId = 'hitBtn';
              }
              else if (e.key === '.') {
                  buttonId = 'kickBtn';
              }
              else if (e.key === 'ArrowDown') {
                  buttonId = 'blockBtn';
                  shouldStopBlock = true;
              }
              else if (e.key === '/') {
                  buttonId = 'specialBtn';
              }
              else if (e.key === 'm') {
                  buttonId = 'grabBtn';
              }
          }
          
          // Remove active class from the button
          if (buttonId) {
              const button = document.getElementById(buttonId);
              if (button) {
                  button.classList.remove('active');
              }
              
              // Stop movement if needed
              if (shouldStopMove && !gameEnding) {
                  socket.emit('stopMove');
              }
              
              // Stop blocking if needed
              if (shouldStopBlock && !gameEnding) {
                  socket.emit('block', {blocking: false});
              }
          }
      }

// Add the missing setupRestartButton function after the handleKeyUp function (around line 1050)

function setupRestartButton() {
    const restartBtn = document.getElementById('restartBtn');
    
    // Add event handler for restart button
    restartBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (socket && playerId) {
            // Play button sound
            playSound('button');
            
            // Send player ready status to server
            socket.emit('playerReady', playerId);
            
            // Update button state
            this.textContent = 'Waiting for other player...';
            this.disabled = true;
            
            debug("Sent playerReady: " + playerId);
        }
    });
}

// Track button presses for combo detection
function trackButtonPress(playerId, buttonType) {
    // Don't track if on cooldown
    if (specialMoveCooldowns[playerId] > 0) return;
    
    // Update the sequence
    buttonCombos[playerId].sequence.push(buttonType);
    buttonCombos[playerId].lastPressTime = performance.now();
    
    // Limit sequence length
    if (buttonCombos[playerId].sequence.length > 5) {
        buttonCombos[playerId].sequence.shift();
    }
    
    // Check for special move combo
    if (checkSpecialMoveCombo(playerId)) {
        executeSpecialMove(playerId);
    }
}

// Check if a special move combo is valid
function checkSpecialMoveCombo(playerId) {
    const combo = buttonCombos[playerId].sequence;
    const now = performance.now();
    
    // Check if combo is recent enough (all button presses within the time window)
    if (combo.length < 3 || now - buttonCombos[playerId].lastPressTime > BUTTON_COMBO_TIMEOUT) {
        // Reset combo if too old
        if (now - buttonCombos[playerId].lastPressTime > BUTTON_COMBO_TIMEOUT) {
            buttonCombos[playerId].sequence = [];
        }
        return false;
    }
    
    // Player 1 special move: hit, hit, kick
    if (playerId === 'player1' && 
        combo.length >= 3 && 
        combo[combo.length-3] === 'hit' && 
        combo[combo.length-2] === 'hit' && 
        combo[combo.length-1] === 'kick') {
        
        // Clear the combo after successful detection
        buttonCombos[playerId].sequence = [];
        return true;
    }
    
    // Player 2 special move: kick, kick, hit
    if (playerId === 'player2' && 
        combo.length >= 3 && 
        combo[combo.length-3] === 'kick' && 
        combo[combo.length-2] === 'kick' && 
        combo[combo.length-1] === 'hit') {
        
        // Clear the combo after successful detection
        buttonCombos[playerId].sequence = [];
        return true;
    }
    
    return false;
}

// Execute a special move
function executeSpecialMove(playerId) {
    if (!players[playerId]) return;
    
    // Check cooldown
    if (specialMoveCooldowns[playerId] > 0) {
        debug(`${playerId} special move on cooldown`);
        return;
    }
    
    // Set special move state
    playerAnimations[playerId].state = SPECIAL_ATTACK;
    playerAnimations[playerId].specialAttackFrame = 0;
    
    // Start cooldown
    specialMoveCooldowns[playerId] = SPECIAL_MOVE_COOLDOWN;
    
    // Play special move sound
    playSound('special');
    
    // Tell the server about the special move
    if (socket) {
        socket.emit('specialMove', { playerId: playerId });
    }
    
    // Check for hit on opponent
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const attackerHitbox = calculateHitboxes(playerId);
    const targetHitbox = calculateHitboxes(opponentId);
    
    if (attackerHitbox && targetHitbox) {
        // Special moves have extended range
        const specialRange = 80;
        const dx = attackerHitbox.body.x - targetHitbox.body.x;
        const dy = attackerHitbox.body.y - targetHitbox.body.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < specialRange) {
            // Check if target is invulnerable
            if (!targetHitbox.invulnerable) {
                // Apply special move damage
                if (socket) {
                    socket.emit('registerHit', {
                        attackerId: playerId,
                        targetId: opponentId,
                        damage: SPECIAL_MOVE_DAMAGE,
                        hitZone: 'special',
                        blocked: targetHitbox.blocking
                    });
                }
                
                // Show special hit feedback
                hitFeedback = {
                    active: true,
                    x: targetHitbox.body.x,
                    y: targetHitbox.body.y,
                    type: 'special',
                    time: performance.now()
                };
            } else {
                // Target is invulnerable
                hitFeedback = {
                    active: true,
                    x: targetHitbox.body.x,
                    y: targetHitbox.body.y,
                    type: 'invulnerable',
                    time: performance.now()
                };
                
                playSound('invulnerable');
            }
        }
    }
}

// Attempt to grab an opponent
function attemptGrab(playerId) {
    if (!players[playerId]) return;
    
    // Can't grab if already grabbing or being grabbed
    if (grabStates[playerId].isGrabbing || grabStates[playerId].isBeingGrabbed) {
        return;
    }
    
    // Set grab attempt state
    playerAnimations[playerId].state = GRAB_ATTEMPT;
    
    // Check for opponent in grab range
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const attackerHitbox = calculateHitboxes(playerId);
    const targetHitbox = calculateHitboxes(opponentId);
    
    if (attackerHitbox && targetHitbox) {
        const dx = attackerHitbox.body.x - targetHitbox.body.x;
        const dy = attackerHitbox.body.y - targetHitbox.body.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < GRAB_RANGE) {
            // Check if target is invulnerable or blocking
            if (!targetHitbox.invulnerable && !targetHitbox.blocking) {
                // Successful grab
                grabStates[playerId].isGrabbing = true;
                grabStates[playerId].grabTarget = opponentId;
                grabStates[playerId].grabStartTime = performance.now();
                
                grabStates[opponentId].isBeingGrabbed = true;
                
                // Set animation states
                playerAnimations[playerId].state = GRAB_ATTEMPT;
                playerAnimations[opponentId].state = GRABBED;
                
                // Play grab sound
                playSound('grab');
                
                debug(`${playerId} grabbed ${opponentId}`);
            } else {
                // Failed grab due to invulnerability or blocking
                setTimeout(() => {
                    if (playerAnimations[playerId].state === GRAB_ATTEMPT) {
                        playerAnimations[playerId].state = IDLE;
                    }
                }, 300);
            }
        } else {
            // Failed grab due to distance
            setTimeout(() => {
                if (playerAnimations[playerId].state === GRAB_ATTEMPT) {
                    playerAnimations[playerId].state = IDLE;
                }
            }, 300);
        }
    }
}

// Attempt to escape from a grab
function attemptGrabEscape(playerId) {
    if (!grabStates[playerId].isBeingGrabbed) return;
    
    // Increment escape attempts
    grabStates[playerId].escapeAttempts++;
    
    // Calculate escape chance based on attempts
    const escapeChance = grabStates[playerId].escapeAttempts * (10 / GRAB_ESCAPE_DIFFICULTY);
    
    // Random check for escape
    if (Math.random() * 100 < escapeChance) {
        // Successful escape
        const grabberId = playerId === 'player1' ? 'player2' : 'player1';
        
        // Reset grab states
        grabStates[grabberId].isGrabbing = false;
        grabStates[grabberId].grabTarget = null;
        grabStates[playerId].isBeingGrabbed = false;
        grabStates[playerId].escapeAttempts = 0;
        
        // Reset animation states
        playerAnimations[grabberId].state = IDLE;
        playerAnimations[playerId].state = IDLE;
        
        debug(`${playerId} escaped from grab`);
    }
}

// Handle grab escape button press
function handleGrabEscapeButtonPress(playerId) {
    if (grabStates[playerId].isBeingGrabbed) {
        // Send grab escape attempt to server
        if (socket) {
            socket.emit('grabEscape', { playerId: playerId });
        }
        
        // Also try locally
        attemptGrabEscape(playerId);
    }
}

// Execute a throw after grabbing
function executeThrow(attackerId, targetId) {
    if (!players[attackerId] || !players[targetId]) return;
    
    // Set states
    playerAnimations[attackerId].state = THROWING;
    playerAnimations[targetId].state = THROWN;
    
    // Calculate throw direction
    const throwDirection = attackerId === 'player1' ? 1 : -1;
    
    // Apply throw distance - send this to the server
    if (socket) {
        socket.emit('throwPlayer', {
            attackerId: attackerId,
            targetId: targetId,
            throwDistance: THROW_DISTANCE * throwDirection
        });
    }
    
    // Apply damage
    if (socket) {
        socket.emit('registerHit', {
            attackerId: attackerId,
            targetId: targetId,
            damage: THROW_DAMAGE,
            hitZone: 'throw',
            blocked: false
        });
    }
    
    // Play throw sound
    playSound('throw');
    
    // Reset grab states
    grabStates[attackerId].isGrabbing = false;
    grabStates[attackerId].grabTarget = null;
    grabStates[targetId].isBeingGrabbed = false;
    
    // Show throw feedback
    const targetPos = calculatePlayerScreenPosition(targetId);
    if (targetPos) {
        hitFeedback = {
            active: true,
            x: targetPos.x + PLAYER_WIDTH / 2,
            y: targetPos.y + PLAYER_HEIGHT / 2,
            type: 'throw',
            time: performance.now()
        };
    }
    
    // Set a timeout to reset the thrown state
    setTimeout(() => {
        if (playerAnimations[targetId].state === THROWN) {
            playerAnimations[targetId].state = IDLE;
        }
    }, THROW_STUN_DURATION);
}

// Game loop
function gameLoop(timestamp) {
    // Calculate delta time for smooth animations
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    // Update animation frame
    animationFrame += ANIMATION_SPEED * (deltaTime / 16.67); // Normalize to ~60fps
    
    // Update player animations
    updatePlayerAnimations(deltaTime);
    
    // Update block cooldowns
    updateBlockCooldowns(deltaTime);

    // Update special move cooldowns
    updateSpecialMoveCooldowns(deltaTime);

    // Update grab states
    updateGrabStates(deltaTime);
    
    // Update hit detection (only if game is active and not ending)
    if (gameStarted && !gameEnding) {
        checkHits();
    }
    
    // Clear canvas
    ctx.clearRect(0, 0, gameWidth, gameHeight);
    
    // Draw game elements
    drawBackground();

    // Always draw players, even if game is not started
    if (players.player1 && players.player2) {
        drawPlayers();
    }

    // Draw hit feedback and power bars if game is active or ending
    if (gameStarted || gameEnding) {
        drawHitFeedback();
        drawPowerBars();

        // Draw special move cooldowns
        if (specialMoveCooldowns.player1 > 0) {
            showSpecialMoveCooldown('player1');
        }
        if (specialMoveCooldowns.player2 > 0) {
            showSpecialMoveCooldown('player2');
        }
        // drawHitboxes(); // Uncomment for debugging
    }

    // Show grab escape instructions
    if (gameStarted && !gameEnding) {
        if (grabStates.player1.isBeingGrabbed) {
            showGrabEscapeInstructions('player1');
        }
        if (grabStates.player2.isBeingGrabbed) {
            showGrabEscapeInstructions('player2');
        }
    }
    
    // Continue the game loop
    requestAnimationFrame(gameLoop);
}

// Update player animations
function updatePlayerAnimations(deltaTime) {
    // Update player 1 animations
    updatePlayerAnimation('player1', deltaTime);
    
    // Update player 2 animations
    updatePlayerAnimation('player2', deltaTime);
}

// Update a single player's animation
function updatePlayerAnimation(playerId, deltaTime) {
    const anim = playerAnimations[playerId];
    
    // Skip if player doesn't exist
    if (!players[playerId]) return;
    
    // Update animation based on state
    switch (anim.state) {
        case IDLE:
            // Breathing animation
            anim.breatheOffset = Math.sin(animationFrame * 0.5) * 2;
            break;
            
        case WALKING:
            // Walking animation
            anim.walkCycle = animationFrame * 2;
            break;
            
        case HITTING:
            // Hitting animation progresses with time
            anim.frame += deltaTime * 0.01;
            if (anim.frame > 1) {
                anim.state = IDLE;
                anim.frame = 0;
            }
            break;
            
        case KICKING:
            // Kicking animation progresses with time
            anim.frame += deltaTime * 0.01;
            if (anim.frame > 1) {
                anim.state = IDLE;
                anim.frame = 0;
            }
            break;
            
        case HURT:
            // Hurt animation - rotate slightly
            anim.hurtAngle += anim.hurtDirection * deltaTime * 0.01;
            if (Math.abs(anim.hurtAngle) > 0.3) {
                anim.hurtDirection *= -1;
            }
            
            // End hurt state after a while
            anim.frame += deltaTime * 0.01;
            if (anim.frame > 1) {
                anim.state = IDLE;
                anim.frame = 0;
                anim.hurtAngle = 0;
            }
            break;
            
        case VICTORY:
            // Victory animation - jump up and down
            anim.victoryJump += deltaTime * 0.01;
            break;
            
        case DEFEAT:
            // Defeat animation - fall down
            anim.defeatFall = Math.min(1, anim.defeatFall + deltaTime * 0.002);
            break;
            
        case SPECIAL_ATTACK:
            // Special attack animation
            anim.specialAttackFrame += deltaTime * 0.01;
            if (anim.specialAttackFrame > Math.PI * 2) {
                anim.state = IDLE;
                anim.specialAttackFrame = 0;
            }
            break;
            
        case THROWN:
            // Thrown animation
            anim.thrownFrame += deltaTime * 0.01;
            if (anim.thrownFrame > 10) {
                anim.state = IDLE;
                anim.thrownFrame = 0;
            }
            break;
    }
}

// Update block cooldowns
function updateBlockCooldowns(deltaTime) {
    // Update player 1 block cooldown
    if (blockCooldowns.player1 > 0) {
        blockCooldowns.player1 = Math.max(0, blockCooldowns.player1 - deltaTime);
        
        // Update cooldown display
        const cooldownPercent = blockCooldowns.player1 / BLOCK_COOLDOWN;
        updateBlockCooldown('player1', cooldownPercent);
    }
    
    // Update player 2 block cooldown
    if (blockCooldowns.player2 > 0) {
        blockCooldowns.player2 = Math.max(0, blockCooldowns.player2 - deltaTime);
        
        // Update cooldown display
        const cooldownPercent = blockCooldowns.player2 / BLOCK_COOLDOWN;
        updateBlockCooldown('player2', cooldownPercent);
    }
}

// Update special move cooldowns
function updateSpecialMoveCooldowns(deltaTime) {
    // Update player 1 special move cooldown
    if (specialMoveCooldowns.player1 > 0) {
        specialMoveCooldowns.player1 = Math.max(0, specialMoveCooldowns.player1 - deltaTime);
    }
    
    // Update player 2 special move cooldown
    if (specialMoveCooldowns.player2 > 0) {
        specialMoveCooldowns.player2 = Math.max(0, specialMoveCooldowns.player2 - deltaTime);
    }
}

// Update grab states
function updateGrabStates(deltaTime) {
    const now = performance.now();
    
    // Check player 1 grab state
    if (grabStates.player1.isGrabbing && grabStates.player1.grabTarget) {
        // Check if grab duration has expired - time to throw
        if (now - grabStates.player1.grabStartTime > GRAB_DURATION) {
            executeThrow('player1', grabStates.player1.grabTarget);
        }
    }
    
    // Check player 2 grab state
    if (grabStates.player2.isGrabbing && grabStates.player2.grabTarget) {
        // Check if grab duration has expired - time to throw
        if (now - grabStates.player2.grabStartTime > GRAB_DURATION) {
            executeThrow('player2', grabStates.player2.grabTarget);
        }
    }
}

// Show special move cooldown indicator
function showSpecialMoveCooldown(playerId) {
    if (specialMoveCooldowns[playerId] <= 0) return;
    
    // Calculate cooldown percentage
    const cooldownPercent = specialMoveCooldowns[playerId] / SPECIAL_MOVE_COOLDOWN;
    
    // Get player position
    const playerPos = calculatePlayerScreenPosition(playerId);
    if (!playerPos) return;
    
    // Draw cooldown indicator
    ctx.save();
    
    // Background circle
    ctx.beginPath();
    ctx.arc(playerPos.x + PLAYER_WIDTH / 2, playerPos.y - 20, 15, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fill();
    
    // Cooldown fill (clockwise from top)
    ctx.beginPath();
    ctx.moveTo(playerPos.x + PLAYER_WIDTH / 2, playerPos.y - 20);
    ctx.arc(
        playerPos.x + PLAYER_WIDTH / 2, 
        playerPos.y - 20, 
        15, 
        -Math.PI / 2, 
        -Math.PI / 2 + (1 - cooldownPercent) * Math.PI * 2
    );
    ctx.closePath();
    ctx.fillStyle = 'rgba(180, 50, 200, 0.7)';
    ctx.fill();
    
    // Border
    ctx.beginPath();
    ctx.arc(playerPos.x + PLAYER_WIDTH / 2, playerPos.y - 20, 15, 0, Math.PI * 2);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Special move icon
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('S', playerPos.x + PLAYER_WIDTH / 2, playerPos.y - 20);
    
    ctx.restore();
}

// Show grab escape instructions
function showGrabEscapeInstructions(playerId) {
    if (!grabStates[playerId].isBeingGrabbed) return;
    
    // Get player position
    const playerPos = calculatePlayerScreenPosition(playerId);
    if (!playerPos) return;
    
    // Draw escape instructions
    ctx.save();
    
    // Text background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(playerPos.x - 40, playerPos.y - 40, 110, 25);
    
    // Text
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Tap buttons to escape!', playerPos.x + PLAYER_WIDTH / 2, playerPos.y - 25);
    
    ctx.restore();
}

// Draw background
function drawBackground() {
    // Simple gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
    gradient.addColorStop(0, '#4a6a8a');
    gradient.addColorStop(1, '#2a3a4a');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, gameWidth, gameHeight);
    
    // Draw floor
    ctx.fillStyle = '#554433';
    ctx.fillRect(0, gameHeight - 50, gameWidth, 50);
}

// Draw hit feedback
function drawHitFeedback() {
    if (!hitFeedback.active) return;
    
    const now = performance.now();
    const elapsed = now - hitFeedback.time;
    
    if (elapsed > HIT_FEEDBACK_DURATION) {
        hitFeedback.active = false;
        return;
    }
    
    // Calculate animation progress (0 to 1)
    const progress = elapsed / HIT_FEEDBACK_DURATION;
    const size = 20 + progress * 30;
    const opacity = 1 - progress;
    
    ctx.save();
    
    // Draw hit effect
    if (hitFeedback.type === 'critical') {
        // Critical hit effect (red burst)
        ctx.fillStyle = `rgba(255, 50, 50, ${opacity})`;
        ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
    } else if (hitFeedback.type === 'blocked') {
        // Blocked hit effect (yellow/gold burst)
        ctx.fillStyle = `rgba(255, 200, 50, ${opacity})`;
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
    } else if (hitFeedback.type === 'special') {
        // Special move hit effect (purple/yellow burst)
        ctx.fillStyle = `rgba(180, 50, 200, ${opacity})`;
        ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
    }
    else if (hitFeedback.type === 'throw') {
        // Throw hit effect (orange burst)
        ctx.fillStyle = `rgba(255, 120, 0, ${opacity})`;
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
    } else if (hitFeedback.type === 'invulnerable') {
        // NEW: Invulnerable hit effect (blue burst)
        ctx.fillStyle = `rgba(74, 144, 226, ${opacity})`;
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
    } else {
        // Normal hit effect (white burst)
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.strokeStyle = `rgba(200, 200, 200, ${opacity})`;
    }
    
    // Draw burst
    ctx.beginPath();
    ctx.arc(hitFeedback.x, hitFeedback.y, size / 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw impact lines
    ctx.lineWidth = 3;
    for (let i = 0; i < 8; i++) {
        const angle = Math.PI * 2 * i / 8;
        const innerRadius = size / 2;
        const outerRadius = size;
        
        ctx.beginPath();
        ctx.moveTo(
            hitFeedback.x + Math.cos(angle) * innerRadius,
            hitFeedback.y + Math.sin(angle) * innerRadius
        );
        ctx.lineTo(
            hitFeedback.x + Math.cos(angle) * outerRadius,
            hitFeedback.y + Math.sin(angle) * outerRadius
        );
        ctx.stroke();
    }
    
    ctx.restore();
}

// Draw power bars
function drawPowerBars() {
    if (!players.player1 || !players.player2) return;
    
    const barWidth = Math.min(300, gameWidth * 0.4);
    const barHeight = 20;
    const margin = 10;
    
    ctx.save();
    
    // Player 1 power bar (left side)
    const p1Power = players.player1.power / MAX_POWER;
    
    // Bar background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(margin, margin, barWidth, barHeight);
    
    // Bar fill
    ctx.fillStyle = p1Power > 0.3 ? 'rgba(255, 50, 50, 0.8)' : 'rgba(255, 50, 50, 0.4)';
    ctx.fillRect(margin, margin, barWidth * p1Power, barHeight);
    
    // Bar border
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.strokeRect(margin, margin, barWidth, barHeight);
    
    // Player 2 power bar (right side)
    const p2Power = players.player2.power / MAX_POWER;
    
    // Bar background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(gameWidth - margin - barWidth, margin, barHeight);
    
    // Bar fill (right-aligned)
    ctx.fillStyle = p2Power > 0.3 ? 'rgba(50, 50, 255, 0.8)' : 'rgba(50, 50, 255, 0.4)';
    ctx.fillRect(gameWidth - margin - barWidth * p2Power, margin, barWidth * p2Power, barHeight);
    
    // Bar border
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.strokeRect(gameWidth - margin - barWidth, margin, barWidth, barHeight);
    
    ctx.restore();
}

// Draw players
function drawPlayers() {
    if (!players.player1 || !players.player2) return;
    
    // Calculate scale factor based on screen width
    const scaleFactor = Math.min(1, gameWidth / 800);
    const floorY = gameHeight - 50;
    
    // Draw player 1 (red)
    drawPlayer('player1', scaleFactor, floorY);
    
    // Draw player 2 (blue)
    drawPlayer('player2', scaleFactor, floorY);
}

// Draw a single player
function drawPlayer(playerId, scaleFactor, floorY) {
    const player = players[playerId];
    const anim = playerAnimations[playerId];
    
    // Adjust player positions for smaller screens
    const screenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, player.x * scaleFactor));
    const screenY = floorY - PLAYER_HEIGHT;
    
    // Set player color
    const playerColor = playerId === 'player1' ? '#ff5555' : '#5555ff';
    const outlineColor = playerId === 'player1' ? '#aa0000' : '#0000aa';
    
    // Apply animation offsets
    let yOffset = 0;
    if (anim.state === IDLE) {
        yOffset = anim.breatheOffset;
    } else if (anim.state === WALKING) {
        yOffset = Math.sin(anim.walkCycle) * 3;
    } else if (anim.state === VICTORY) {
        yOffset = -Math.abs(Math.sin(anim.victoryJump) * 20);
    } else if (anim.state === DEFEAT) {
        yOffset = anim.defeatFall * 20;
    }
    
    ctx.save();
    
    // Apply hurt animation rotation
    if (anim.state === HURT) {
        const centerX = screenX + PLAYER_WIDTH / 2;
        const centerY = screenY + PLAYER_HEIGHT / 2;
        
        ctx.translate(centerX, centerY);
        ctx.rotate(anim.hurtAngle);
        ctx.translate(-centerX, -centerY);
    }
    
    // NEW: Apply invulnerability effect
    if (player.isInvulnerable) {
        ctx.globalAlpha = 0.5 + Math.sin(performance.now() / 100) * 0.3; // Pulsing effect
    }
    
    // Draw stick figure
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = outlineColor;
    
    // Head
    ctx.beginPath();
    ctx.arc(screenX + PLAYER_WIDTH / 2, screenY + 15 + yOffset, 10, 0, Math.PI * 2);
    ctx.fillStyle = playerColor;
    ctx.fill();
    ctx.stroke();
    
    // Body
    ctx.beginPath();
    ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 25 + yOffset);
    ctx.lineTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
    ctx.stroke();
    
    // Draw arms based on animation state
    if (anim.state === HITTING) {
        // Hitting animation - extend one arm
        const punchExtension = 10;
        const facingLeft = playerId === 'player2';
        
        // Back arm
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? 15 : -15),
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        // Punching arm
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -25 - punchExtension : 25 + punchExtension),
            screenY + 30 + yOffset
        );
        ctx.stroke();
    } else if (anim.state === KICKING) {
        // Kicking animation - extend one leg
        const kickExtension = 15;
        const facingLeft = playerId === 'player2';
        
        // Arms in ready position
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? 15 : -15),
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -15 : 15),
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        // Standing leg
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? 5 : -5),
            screenY + 80 + yOffset
        );
        ctx.stroke();
        
        // Kicking leg
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -30 - kickExtension : 30 + kickExtension),
            screenY + 60 + yOffset
        );
        ctx.stroke();
    } else if (anim.state === BLOCKING) {
        // Blocking animation - arms crossed in front
        const facingLeft = playerId === 'player2';
        
        // Arms crossed in X shape
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -15 : 15),
            screenY + 25 + yOffset
        );
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -15 : 15),
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        // Draw block shield effect
        ctx.beginPath();
        ctx.arc(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -15 : 15),
            screenY + 35 + yOffset,
            15,
            0,
            Math.PI * 2
        );
        ctx.fillStyle = `rgba(255, 200, 50, 0.3)`;
        ctx.fill();
        ctx.strokeStyle = `rgba(255, 200, 50, 0.7)`;
        ctx.stroke();
        
        // Legs in stable stance
        ctx.strokeStyle = outlineColor;
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 15, screenY + 80 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 15, screenY + 80 + yOffset);
        ctx.stroke();
    } else if (anim.state === VICTORY) {
        // Victory animation - arms up
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 15, screenY + 15 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 15, screenY + 15 + yOffset);
        ctx.stroke();
        
        // Legs
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 10, screenY + 80 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 10, screenY + 80 + yOffset);
        ctx.stroke();
    } else if (anim.state === DEFEAT) {
        // Defeat animation - slumped over
        
        // Arms hanging down
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 10, screenY + 55 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 10, screenY + 55 + yOffset);
        ctx.stroke();
        
        // Legs crumpled
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 15, screenY + 75 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 15, screenY + 75 + yOffset);
        ctx.stroke();
    } else if (anim.state === WALKING) {
        // Walking animation
        const walkOffset = Math.sin(anim.walkCycle);
        const facingLeft = playerId === 'player2';
        
        // Arms swinging
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? 15 : -15) + walkOffset * 5,
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -15 : 15) - walkOffset * 5,
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        // Legs walking
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + walkOffset * 10,
            screenY + 80 + yOffset
        );
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 - walkOffset * 10,
            screenY + 80 + yOffset
        );
        ctx.stroke();
    } else if (anim.state === SPECIAL_ATTACK) {
        // Special attack animation
        const facingLeft = playerId === 'player2';
        
        // Animate special attack (spinning attack)
        const spinAngle = anim.specialAttackFrame * 0.5;
        anim.specialAttackFrame += 0.2;
        
        // Rotate the entire player for spin attack
        const centerX = screenX + PLAYER_WIDTH / 2;
        const centerY = screenY + PLAYER_HEIGHT / 2;
        
        ctx.translate(centerX, centerY);
        ctx.rotate(spinAngle);
        ctx.translate(-centerX, -centerY);
        
        // Draw extended arms for special attack
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 25, screenY + 15 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 25, screenY + 15 + yOffset);
        ctx.stroke();
        
        // Draw special effect
        ctx.beginPath();
        ctx.arc(screenX + PLAYER_WIDTH / 2, screenY + PLAYER_HEIGHT / 2, 30, 0, Math.PI * 2);
        ctx.fillStyle = playerId === 'player1' ? 'rgba(255, 50, 50, 0.3)' : 'rgba(50, 50, 255, 0.3)';
        ctx.fill();
        
        // Add a second glowing effect
        ctx.beginPath();
        ctx.arc(screenX + PLAYER_WIDTH / 2, screenY + PLAYER_HEIGHT / 2, 40, 0, Math.PI * 2);
        ctx.fillStyle = playerId === 'player1' ? 'rgba(255, 50, 50, 0.1)' : 'rgba(50, 50, 255, 0.1)';
        ctx.fill();
        
        // Reset special attack after a full rotation
        if (spinAngle > Math.PI * 2) {
            anim.specialAttackFrame = 0;
            anim.state = IDLE;
        }
        
        // Legs in wide stance
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 15, screenY + 80 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 15, screenY + 80 + yOffset);
        ctx.stroke();
    }
    else if (anim.state === GRAB_ATTEMPT) {
        // Grab attempt animation - arms reaching forward
        const facingLeft = playerId === 'player2';
        
        // Arms reaching forward
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -20 : 20),
            screenY + 25 + yOffset
        );
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -20 : 20),
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        // Legs in stable stance
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 10, screenY + 80 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 10, screenY + 80 + yOffset);
        ctx.stroke();
    }
    else if (anim.state === GRABBED) {
        // Being grabbed animation - arms pinned
        
        // Arms pinned to sides
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 5, screenY + 55 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 5, screenY + 55 + yOffset);
        ctx.stroke();
        
        // Legs slightly bent
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 8, screenY + 75 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 8, screenY + 75 + yOffset);
        ctx.stroke();
    }
    else if (anim.state === THROWING) {
        // Throwing animation - arms extended forcefully
        const facingLeft = playerId === 'player2';
        
        // Arms extended in throwing motion
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -30 : 30),
            screenY + 25 + yOffset
        );
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(
            screenX + PLAYER_WIDTH / 2 + (facingLeft ? -25 : 25),
            screenY + 45 + yOffset
        );
        ctx.stroke();
        
        // Legs in wide stance
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 15, screenY + 80 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 15, screenY + 80 + yOffset);
        ctx.stroke();
        
        // Reset to idle after animation completes
        anim.throwFrame++;
        if (anim.throwFrame > 10) {
            anim.throwFrame = 0;
            anim.state = IDLE;
        }
    }
    else if (anim.state === THROWN) {
        // Being thrown animation - tumbling in air
        
        // Rotate the player to show tumbling
        const centerX = screenX + PLAYER_WIDTH / 2;
        const centerY = screenY + PLAYER_HEIGHT / 2;
        
        ctx.translate(centerX, centerY);
        ctx.rotate(anim.thrownFrame * 0.3);
        ctx.translate(-centerX, -centerY);
        
        // Arms flailing
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 20, screenY + 25 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 20, screenY + 45 + yOffset);
        ctx.stroke();
        
        // Legs flailing
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 20, screenY + 65 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 20, screenY + 75 + yOffset);
        ctx.stroke();
        
        // Increment thrown animation frame
        anim.thrownFrame++;
    } else {
        // Default idle pose
        
        // Arms
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 15, screenY + 45 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 35 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 15, screenY + 45 + yOffset);
        ctx.stroke();
        
        // Legs
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 - 10, screenY + 80 + yOffset);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(screenX + PLAYER_WIDTH / 2, screenY + 55 + yOffset);
        ctx.lineTo(screenX + PLAYER_WIDTH / 2 + 10, screenY + 80 + yOffset);
        ctx.stroke();
    }
    
    ctx.restore();
}

// Check for hits between players
function checkHits() {
    if (!gameStarted || !players.player1 || !players.player2 || gameEnding) return;
    
    // Don't check hits too frequently
    const now = performance.now();
    if (now - lastHitTime < HIT_COOLDOWN) return;
    
    // Calculate hitboxes
    const p1Hitbox = calculateHitboxes('player1');
    const p2Hitbox = calculateHitboxes('player2');
    
    if (!p1Hitbox || !p2Hitbox) return;
    
    // Check player 1 attacking player 2
    if (p1Hitbox.attackPoint.active && players.player1.state !== HURT && 
        !grabStates.player1.isBeingGrabbed && !grabStates.player2.isBeingGrabbed) {
        const hit = detectHit(p1Hitbox.attackPoint, p2Hitbox);
        if (hit) {
            // NEW: Check if target is invulnerable
            if (!p2Hitbox.invulnerable) {
                applyHit('player1', 'player2', p1Hitbox.attackPoint, hit, p2Hitbox.blocking);
            } else {
                // Play invulnerable sound
                playSound('invulnerable');
                
                // Show invulnerable feedback
                hitFeedback = {
                    active: true,
                    x: hit.point.x,
                    y: hit.point.y,
                    type: 'invulnerable',
                    time: performance.now()
                };
            }
        }
    }
    
    // Check player 2 attacking player 1
    if (p2Hitbox.attackPoint.active && players.player2.state !== HURT && 
        !grabStates.player2.isBeingGrabbed && !grabStates.player1.isBeingGrabbed) {
        const hit = detectHit(p2Hitbox.attackPoint, p1Hitbox);
        if (hit) {
            // NEW: Check if target is invulnerable
            if (!p1Hitbox.invulnerable) {
                applyHit('player2', 'player1', p2Hitbox.attackPoint, hit, p1Hitbox.blocking);
            } else {
                // Play invulnerable sound
                playSound('invulnerable');
                
                // Show invulnerable feedback
                hitFeedback = {
                    active: true,
                    x: hit.point.x,
                    y: hit.point.y,
                    type: 'invulnerable',
                    time: performance.now()
                };
            }
        }
    }
}

// Detect hit between attack point and target hitbox
function detectHit(attackPoint, targetHitbox) {
    // Get attack range (or default to 10)
    const range = attackPoint.range || 10;
    
    // Check head hit (circular collision)
    const dx = attackPoint.x - targetHitbox.head.x;
    const dy = attackPoint.y - targetHitbox.head.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < targetHitbox.head.radius + range) {
        return { zone: 'head', point: { x: targetHitbox.head.x, y: targetHitbox.head.y } };
    }
    
    // Check body hit (rectangular collision with expanded range)
    const bodyLeft = targetHitbox.body.x - targetHitbox.body.width / 2 - range;
    const bodyRight = targetHitbox.body.x + targetHitbox.body.width / 2 + range;
    const bodyTop = targetHitbox.body.y - targetHitbox.body.height / 2 - range;
    const bodyBottom = targetHitbox.body.y + targetHitbox.body.height / 2 + range;
    
    if (attackPoint.x >= bodyLeft && attackPoint.x <= bodyRight &&
        attackPoint.y >= bodyTop && attackPoint.y <= bodyBottom) {
        return { zone: 'body', point: { x: attackPoint.x, y: attackPoint.y } };
    }
    
    return null;
}

// Apply hit to target
function applyHit(attackerId, targetId, attackPoint, hit, isBlocking) {
    // Don't register hits if the game is over
    if (gameEnding || document.getElementById('winnerMessage').style.display === 'block') return;
    
    lastHitTime = performance.now();
    
    // Calculate damage based on attack type and hit zone
    let damage = attackPoint.type === 'hit' ? HIT_DAMAGE : KICK_DAMAGE;
    
    // Critical hit for headshots
    if (hit.zone === 'head') {
        damage *= CRITICAL_HIT_MULTIPLIER;
    }
    
    // Reduce damage if blocking
    if (isBlocking) {
        damage *= (1 - BLOCK_DAMAGE_REDUCTION);
        
        // Play block hit sound
        playSound('blockHit');
    }
    
    // NEW: Update combo counter
    const now = performance.now();
    const timeSinceLastHit = now - lastHitTimes[targetId];
    
    // Reset combo if it's been a while since the last hit
    if (timeSinceLastHit > COMBO_RESET_TIME) {
        comboCounts[attackerId] = 0;
    }
    
    // Increment combo counter
    comboCounts[attackerId]++;
    
    // Update last hit time
    lastHitTimes[targetId] = now;
    
    // Send attack to server
    if (socket) {
        socket.emit('registerHit', {
            attackerId: attackerId,
            targetId: targetId,
            damage: damage,
            hitZone: hit.zone,
            blocked: isBlocking,
            comboCount: comboCounts[attackerId] // NEW: Send combo count
        });
    }
    
    // Show hit feedback
    hitFeedback = {
        active: true,
        x: hit.point.x,
        y: hit.point.y,
        type: isBlocking ? 'blocked' : (hit.zone === 'head' ? 'critical' : 'normal'),
        time: performance.now()
    };
}

// Calculate hitboxes for a player
function calculateHitboxes(playerId) {
    if (!players[playerId]) return null;
    
    const player = players[playerId];
    const anim = playerAnimations[playerId];
    const facingLeft = playerId === 'player2'; // Player 2 faces left
    
    // Calculate scale factor based on screen width
    const scaleFactor = Math.min(1, gameWidth / 800);
    const floorY = gameHeight - 50;
    
    // Adjust player positions for smaller screens
    const screenX = Math.max(0, Math.min(gameWidth - PLAYER_WIDTH, player.x * scaleFactor));
    const screenY = floorY - PLAYER_HEIGHT;
    
    // Apply animation offsets
    let yOffset = 0;
    if (anim.state === VICTORY) {
        yOffset = -Math.abs(Math.sin(anim.victoryJump) * 20);
    } else if (anim.state === DEFEAT) {
        yOffset = anim.defeatFall * 20;
    }
    
    // Calculate center point
    const centerX = screenX + PLAYER_WIDTH / 2;
    const headY = screenY + 10 + anim.breatheOffset + yOffset;
    
    // Calculate attack point (where hits land)
    let attackX = centerX + (facingLeft ? -ARM_HITBOX_WIDTH : ARM_HITBOX_WIDTH);
    let attackY = screenY + 25 + yOffset;
    let attackRange = 10; // Default attack range

    if (anim.state === HITTING) {
        attackRange = 10;
    } else if (anim.state === KICKING) {
        // Extend kick range and adjust position
        attackX = centerX + (facingLeft ? -LEG_HITBOX_WIDTH - 10 : LEG_HITBOX_WIDTH + 10);
        attackY = screenY + 60 + yOffset;
        attackRange = 15; // Larger range for kicks
    }
    
    return {
        id: playerId,
        head: {
            x: centerX,
            y: headY,
            radius: HEAD_HITBOX_RADIUS
        },
        body: {
            x: centerX,
            y: screenY + 35 + yOffset,
            width: BODY_HITBOX_WIDTH,
            height: BODY_HITBOX_HEIGHT
        },
        attackPoint: {
            x: attackX,
            y: attackY,
            active: anim.state === HITTING || anim.state === KICKING,
            type: anim.state === HITTING ? 'hit' : 'kick',
            range: attackRange
        },
        blocking: anim.state === BLOCKING,
        // NEW: Add invulnerability status to hitbox
        invulnerable: player.isInvulnerable || false
    };
}

// Show winner message
function showWinner(winnerId) {
    const winnerMessage = document.getElementById('winnerMessage');
    const winnerText = document.getElementById('winnerText');
    
    // Set winner text
    winnerText.textContent = winnerId === 'player1' ? 'Player 1 Wins!' : 'Player 2 Wins!';
    
    // Show winner message
    winnerMessage.style.display = 'block';
    
    // Play victory sound
    playSound('victory');
}
</script>
</body>
</html>
